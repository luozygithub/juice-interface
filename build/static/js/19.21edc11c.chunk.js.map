{"version":3,"sources":["../../src.ts/index.ts","../../src.ts/_version.ts","../../src.ts/formatter.ts","../../src.ts/base-provider.ts","../../src.ts/json-rpc-provider.ts","../../src.ts/browser-ws.ts","../../src.ts/websocket-provider.ts","../../src.ts/url-json-rpc-provider.ts","../../src.ts/alchemy-provider.ts","../../src.ts/cloudflare-provider.ts","../../src.ts/etherscan-provider.ts","../../src.ts/fallback-provider.ts","../../src.ts/browser-ipc-provider.ts","../../src.ts/infura-provider.ts","../../src.ts/json-rpc-batch-provider.ts","../../src.ts/nodesmith-provider.ts","../../src.ts/pocket-provider.ts","../../src.ts/web3-provider.ts","../../src.ts/ethers.ts","../../src.ts/strings.ts"],"names":["formats","transaction","allowNull","serializeTopics","topics","slice","length","unique","topic","forEach","checkTopic","sort","coinType","this","errorGas","message","error","WS","logger","throwError","errors","UNSUPPORTED_OPERATION","operation","result","code","data","match","UNPREDICTABLE_GAS_LIMIT","method","median","values","middle","Math","floor","value","keys","Object","map","key","v","Error","host","apiKey","provider","EtherSymbol"],"mappings":"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","file":"static/js/19.21edc11c.chunk.js","sourcesContent":["\"use strict\";\nexport { AddressZero } from \"./addresses\";\nexport { NegativeOne, Zero, One, Two, WeiPerEther, MaxUint256, MinInt256, MaxInt256 } from \"./bignumbers\";\nexport { HashZero } from \"./hashes\";\nexport { EtherSymbol } from \"./strings\";\n//# sourceMappingURL=index.js.map","export const version = \"ethers/5.4.7\";\n//# sourceMappingURL=_version.js.map","\"use strict\";\nimport { getAddress, getContractAddress } from \"@ethersproject/address\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { hexDataLength, hexDataSlice, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { AddressZero } from \"@ethersproject/constants\";\nimport { shallowCopy } from \"@ethersproject/properties\";\nimport { accessListify, parse as parseTransaction } from \"@ethersproject/transactions\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nexport class Formatter {\n    constructor() {\n        logger.checkNew(new.target, Formatter);\n        this.formats = this.getDefaultFormats();\n    }\n    getDefaultFormats() {\n        const formats = ({});\n        const address = this.address.bind(this);\n        const bigNumber = this.bigNumber.bind(this);\n        const blockTag = this.blockTag.bind(this);\n        const data = this.data.bind(this);\n        const hash = this.hash.bind(this);\n        const hex = this.hex.bind(this);\n        const number = this.number.bind(this);\n        const type = this.type.bind(this);\n        const strictData = (v) => { return this.data(v, true); };\n        formats.transaction = {\n            hash: hash,\n            type: type,\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n            blockHash: Formatter.allowNull(hash, null),\n            blockNumber: Formatter.allowNull(number, null),\n            transactionIndex: Formatter.allowNull(number, null),\n            confirmations: Formatter.allowNull(number, null),\n            from: address,\n            // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)\n            // must be set\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n            gasLimit: bigNumber,\n            to: Formatter.allowNull(address, null),\n            value: bigNumber,\n            nonce: number,\n            data: data,\n            r: Formatter.allowNull(this.uint256),\n            s: Formatter.allowNull(this.uint256),\n            v: Formatter.allowNull(number),\n            creates: Formatter.allowNull(address, null),\n            raw: Formatter.allowNull(data),\n        };\n        formats.transactionRequest = {\n            from: Formatter.allowNull(address),\n            nonce: Formatter.allowNull(number),\n            gasLimit: Formatter.allowNull(bigNumber),\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n            to: Formatter.allowNull(address),\n            value: Formatter.allowNull(bigNumber),\n            data: Formatter.allowNull(strictData),\n            type: Formatter.allowNull(number),\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n        };\n        formats.receiptLog = {\n            transactionIndex: number,\n            blockNumber: number,\n            transactionHash: hash,\n            address: address,\n            topics: Formatter.arrayOf(hash),\n            data: data,\n            logIndex: number,\n            blockHash: hash,\n        };\n        formats.receipt = {\n            to: Formatter.allowNull(this.address, null),\n            from: Formatter.allowNull(this.address, null),\n            contractAddress: Formatter.allowNull(address, null),\n            transactionIndex: number,\n            // should be allowNull(hash), but broken-EIP-658 support is handled in receipt\n            root: Formatter.allowNull(hex),\n            gasUsed: bigNumber,\n            logsBloom: Formatter.allowNull(data),\n            blockHash: hash,\n            transactionHash: hash,\n            logs: Formatter.arrayOf(this.receiptLog.bind(this)),\n            blockNumber: number,\n            confirmations: Formatter.allowNull(number, null),\n            cumulativeGasUsed: bigNumber,\n            effectiveGasPrice: Formatter.allowNull(bigNumber),\n            status: Formatter.allowNull(number),\n            type: type\n        };\n        formats.block = {\n            hash: hash,\n            parentHash: hash,\n            number: number,\n            timestamp: number,\n            nonce: Formatter.allowNull(hex),\n            difficulty: this.difficulty.bind(this),\n            gasLimit: bigNumber,\n            gasUsed: bigNumber,\n            miner: address,\n            extraData: data,\n            transactions: Formatter.allowNull(Formatter.arrayOf(hash)),\n            baseFeePerGas: Formatter.allowNull(bigNumber)\n        };\n        formats.blockWithTransactions = shallowCopy(formats.block);\n        formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));\n        formats.filter = {\n            fromBlock: Formatter.allowNull(blockTag, undefined),\n            toBlock: Formatter.allowNull(blockTag, undefined),\n            blockHash: Formatter.allowNull(hash, undefined),\n            address: Formatter.allowNull(address, undefined),\n            topics: Formatter.allowNull(this.topics.bind(this), undefined),\n        };\n        formats.filterLog = {\n            blockNumber: Formatter.allowNull(number),\n            blockHash: Formatter.allowNull(hash),\n            transactionIndex: number,\n            removed: Formatter.allowNull(this.boolean.bind(this)),\n            address: address,\n            data: Formatter.allowFalsish(data, \"0x\"),\n            topics: Formatter.arrayOf(hash),\n            transactionHash: hash,\n            logIndex: number,\n        };\n        return formats;\n    }\n    accessList(accessList) {\n        return accessListify(accessList || []);\n    }\n    // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number\n    // Strict! Used on input.\n    number(number) {\n        if (number === \"0x\") {\n            return 0;\n        }\n        return BigNumber.from(number).toNumber();\n    }\n    type(number) {\n        if (number === \"0x\" || number == null) {\n            return 0;\n        }\n        return BigNumber.from(number).toNumber();\n    }\n    // Strict! Used on input.\n    bigNumber(value) {\n        return BigNumber.from(value);\n    }\n    // Requires a boolean, \"true\" or  \"false\"; returns a boolean\n    boolean(value) {\n        if (typeof (value) === \"boolean\") {\n            return value;\n        }\n        if (typeof (value) === \"string\") {\n            value = value.toLowerCase();\n            if (value === \"true\") {\n                return true;\n            }\n            if (value === \"false\") {\n                return false;\n            }\n        }\n        throw new Error(\"invalid boolean - \" + value);\n    }\n    hex(value, strict) {\n        if (typeof (value) === \"string\") {\n            if (!strict && value.substring(0, 2) !== \"0x\") {\n                value = \"0x\" + value;\n            }\n            if (isHexString(value)) {\n                return value.toLowerCase();\n            }\n        }\n        return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n    }\n    data(value, strict) {\n        const result = this.hex(value, strict);\n        if ((result.length % 2) !== 0) {\n            throw new Error(\"invalid data; odd-length - \" + value);\n        }\n        return result;\n    }\n    // Requires an address\n    // Strict! Used on input.\n    address(value) {\n        return getAddress(value);\n    }\n    callAddress(value) {\n        if (!isHexString(value, 32)) {\n            return null;\n        }\n        const address = getAddress(hexDataSlice(value, 12));\n        return (address === AddressZero) ? null : address;\n    }\n    contractAddress(value) {\n        return getContractAddress(value);\n    }\n    // Strict! Used on input.\n    blockTag(blockTag) {\n        if (blockTag == null) {\n            return \"latest\";\n        }\n        if (blockTag === \"earliest\") {\n            return \"0x0\";\n        }\n        if (blockTag === \"latest\" || blockTag === \"pending\") {\n            return blockTag;\n        }\n        if (typeof (blockTag) === \"number\" || isHexString(blockTag)) {\n            return hexValue(blockTag);\n        }\n        throw new Error(\"invalid blockTag\");\n    }\n    // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.\n    hash(value, strict) {\n        const result = this.hex(value, strict);\n        if (hexDataLength(result) !== 32) {\n            return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n        }\n        return result;\n    }\n    // Returns the difficulty as a number, or if too large (i.e. PoA network) null\n    difficulty(value) {\n        if (value == null) {\n            return null;\n        }\n        const v = BigNumber.from(value);\n        try {\n            return v.toNumber();\n        }\n        catch (error) { }\n        return null;\n    }\n    uint256(value) {\n        if (!isHexString(value)) {\n            throw new Error(\"invalid uint256\");\n        }\n        return hexZeroPad(value, 32);\n    }\n    _block(value, format) {\n        if (value.author != null && value.miner == null) {\n            value.miner = value.author;\n        }\n        return Formatter.check(format, value);\n    }\n    block(value) {\n        return this._block(value, this.formats.block);\n    }\n    blockWithTransactions(value) {\n        return this._block(value, this.formats.blockWithTransactions);\n    }\n    // Strict! Used on input.\n    transactionRequest(value) {\n        return Formatter.check(this.formats.transactionRequest, value);\n    }\n    transactionResponse(transaction) {\n        // Rename gas to gasLimit\n        if (transaction.gas != null && transaction.gasLimit == null) {\n            transaction.gasLimit = transaction.gas;\n        }\n        // Some clients (TestRPC) do strange things like return 0x0 for the\n        // 0 address; correct this to be a real address\n        if (transaction.to && BigNumber.from(transaction.to).isZero()) {\n            transaction.to = \"0x0000000000000000000000000000000000000000\";\n        }\n        // Rename input to data\n        if (transaction.input != null && transaction.data == null) {\n            transaction.data = transaction.input;\n        }\n        // If to and creates are empty, populate the creates from the transaction\n        if (transaction.to == null && transaction.creates == null) {\n            transaction.creates = this.contractAddress(transaction);\n        }\n        if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) {\n            transaction.accessList = [];\n        }\n        const result = Formatter.check(this.formats.transaction, transaction);\n        if (transaction.chainId != null) {\n            let chainId = transaction.chainId;\n            if (isHexString(chainId)) {\n                chainId = BigNumber.from(chainId).toNumber();\n            }\n            result.chainId = chainId;\n        }\n        else {\n            let chainId = transaction.networkId;\n            // geth-etc returns chainId\n            if (chainId == null && result.v == null) {\n                chainId = transaction.chainId;\n            }\n            if (isHexString(chainId)) {\n                chainId = BigNumber.from(chainId).toNumber();\n            }\n            if (typeof (chainId) !== \"number\" && result.v != null) {\n                chainId = (result.v - 35) / 2;\n                if (chainId < 0) {\n                    chainId = 0;\n                }\n                chainId = parseInt(chainId);\n            }\n            if (typeof (chainId) !== \"number\") {\n                chainId = 0;\n            }\n            result.chainId = chainId;\n        }\n        // 0x0000... should actually be null\n        if (result.blockHash && result.blockHash.replace(/0/g, \"\") === \"x\") {\n            result.blockHash = null;\n        }\n        return result;\n    }\n    transaction(value) {\n        return parseTransaction(value);\n    }\n    receiptLog(value) {\n        return Formatter.check(this.formats.receiptLog, value);\n    }\n    receipt(value) {\n        const result = Formatter.check(this.formats.receipt, value);\n        // RSK incorrectly implemented EIP-658, so we munge things a bit here for it\n        if (result.root != null) {\n            if (result.root.length <= 4) {\n                // Could be 0x00, 0x0, 0x01 or 0x1\n                const value = BigNumber.from(result.root).toNumber();\n                if (value === 0 || value === 1) {\n                    // Make sure if both are specified, they match\n                    if (result.status != null && (result.status !== value)) {\n                        logger.throwArgumentError(\"alt-root-status/status mismatch\", \"value\", { root: result.root, status: result.status });\n                    }\n                    result.status = value;\n                    delete result.root;\n                }\n                else {\n                    logger.throwArgumentError(\"invalid alt-root-status\", \"value.root\", result.root);\n                }\n            }\n            else if (result.root.length !== 66) {\n                // Must be a valid bytes32\n                logger.throwArgumentError(\"invalid root hash\", \"value.root\", result.root);\n            }\n        }\n        if (result.status != null) {\n            result.byzantium = true;\n        }\n        return result;\n    }\n    topics(value) {\n        if (Array.isArray(value)) {\n            return value.map((v) => this.topics(v));\n        }\n        else if (value != null) {\n            return this.hash(value, true);\n        }\n        return null;\n    }\n    filter(value) {\n        return Formatter.check(this.formats.filter, value);\n    }\n    filterLog(value) {\n        return Formatter.check(this.formats.filterLog, value);\n    }\n    static check(format, object) {\n        const result = {};\n        for (const key in format) {\n            try {\n                const value = format[key](object[key]);\n                if (value !== undefined) {\n                    result[key] = value;\n                }\n            }\n            catch (error) {\n                error.checkKey = key;\n                error.checkValue = object[key];\n                throw error;\n            }\n        }\n        return result;\n    }\n    // if value is null-ish, nullValue is returned\n    static allowNull(format, nullValue) {\n        return (function (value) {\n            if (value == null) {\n                return nullValue;\n            }\n            return format(value);\n        });\n    }\n    // If value is false-ish, replaceValue is returned\n    static allowFalsish(format, replaceValue) {\n        return (function (value) {\n            if (!value) {\n                return replaceValue;\n            }\n            return format(value);\n        });\n    }\n    // Requires an Array satisfying check\n    static arrayOf(format) {\n        return (function (array) {\n            if (!Array.isArray(array)) {\n                throw new Error(\"not an array\");\n            }\n            const result = [];\n            array.forEach(function (value) {\n                result.push(format(value));\n            });\n            return result;\n        });\n    }\n}\nexport function isCommunityResourcable(value) {\n    return (value && typeof (value.isCommunityResource) === \"function\");\n}\nexport function isCommunityResource(value) {\n    return (isCommunityResourcable(value) && value.isCommunityResource());\n}\n// Show the throttle message only once\nlet throttleMessage = false;\nexport function showThrottleMessage() {\n    if (throttleMessage) {\n        return;\n    }\n    throttleMessage = true;\n    console.log(\"========= NOTICE =========\");\n    console.log(\"Request-Rate Exceeded  (this message will not be repeated)\");\n    console.log(\"\");\n    console.log(\"The default API keys for each service are provided as a highly-throttled,\");\n    console.log(\"community resource for low-traffic projects and early prototyping.\");\n    console.log(\"\");\n    console.log(\"While your application will continue to function, we highly recommended\");\n    console.log(\"signing up for your own API keys to improve performance, increase your\");\n    console.log(\"request rate/limit and enable other perks, such as metrics and advanced APIs.\");\n    console.log(\"\");\n    console.log(\"For more details: https:/\\/docs.ethers.io/api-keys/\");\n    console.log(\"==========================\");\n}\n//# sourceMappingURL=formatter.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ForkEvent, Provider } from \"@ethersproject/abstract-provider\";\nimport { Base58 } from \"@ethersproject/basex\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { arrayify, concat, hexConcat, hexDataLength, hexDataSlice, hexlify, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { HashZero } from \"@ethersproject/constants\";\nimport { namehash } from \"@ethersproject/hash\";\nimport { getNetwork } from \"@ethersproject/networks\";\nimport { defineReadOnly, getStatic, resolveProperties } from \"@ethersproject/properties\";\nimport { sha256 } from \"@ethersproject/sha2\";\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\nimport { poll } from \"@ethersproject/web\";\nimport bech32 from \"bech32\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { Formatter } from \"./formatter\";\n//////////////////////////////\n// Event Serializeing\nfunction checkTopic(topic) {\n    if (topic == null) {\n        return \"null\";\n    }\n    if (hexDataLength(topic) !== 32) {\n        logger.throwArgumentError(\"invalid topic\", \"topic\", topic);\n    }\n    return topic.toLowerCase();\n}\nfunction serializeTopics(topics) {\n    // Remove trailing null AND-topics; they are redundant\n    topics = topics.slice();\n    while (topics.length > 0 && topics[topics.length - 1] == null) {\n        topics.pop();\n    }\n    return topics.map((topic) => {\n        if (Array.isArray(topic)) {\n            // Only track unique OR-topics\n            const unique = {};\n            topic.forEach((topic) => {\n                unique[checkTopic(topic)] = true;\n            });\n            // The order of OR-topics does not matter\n            const sorted = Object.keys(unique);\n            sorted.sort();\n            return sorted.join(\"|\");\n        }\n        else {\n            return checkTopic(topic);\n        }\n    }).join(\"&\");\n}\nfunction deserializeTopics(data) {\n    if (data === \"\") {\n        return [];\n    }\n    return data.split(/&/g).map((topic) => {\n        if (topic === \"\") {\n            return [];\n        }\n        const comps = topic.split(\"|\").map((topic) => {\n            return ((topic === \"null\") ? null : topic);\n        });\n        return ((comps.length === 1) ? comps[0] : comps);\n    });\n}\nfunction getEventTag(eventName) {\n    if (typeof (eventName) === \"string\") {\n        eventName = eventName.toLowerCase();\n        if (hexDataLength(eventName) === 32) {\n            return \"tx:\" + eventName;\n        }\n        if (eventName.indexOf(\":\") === -1) {\n            return eventName;\n        }\n    }\n    else if (Array.isArray(eventName)) {\n        return \"filter:*:\" + serializeTopics(eventName);\n    }\n    else if (ForkEvent.isForkEvent(eventName)) {\n        logger.warn(\"not implemented\");\n        throw new Error(\"not implemented\");\n    }\n    else if (eventName && typeof (eventName) === \"object\") {\n        return \"filter:\" + (eventName.address || \"*\") + \":\" + serializeTopics(eventName.topics || []);\n    }\n    throw new Error(\"invalid event - \" + eventName);\n}\n//////////////////////////////\n// Helper Object\nfunction getTime() {\n    return (new Date()).getTime();\n}\nfunction stall(duration) {\n    return new Promise((resolve) => {\n        setTimeout(resolve, duration);\n    });\n}\n//////////////////////////////\n// Provider Object\n/**\n *  EventType\n *   - \"block\"\n *   - \"poll\"\n *   - \"didPoll\"\n *   - \"pending\"\n *   - \"error\"\n *   - \"network\"\n *   - filter\n *   - topics array\n *   - transaction hash\n */\nconst PollableEvents = [\"block\", \"network\", \"pending\", \"poll\"];\nexport class Event {\n    constructor(tag, listener, once) {\n        defineReadOnly(this, \"tag\", tag);\n        defineReadOnly(this, \"listener\", listener);\n        defineReadOnly(this, \"once\", once);\n    }\n    get event() {\n        switch (this.type) {\n            case \"tx\":\n                return this.hash;\n            case \"filter\":\n                return this.filter;\n        }\n        return this.tag;\n    }\n    get type() {\n        return this.tag.split(\":\")[0];\n    }\n    get hash() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"tx\") {\n            return null;\n        }\n        return comps[1];\n    }\n    get filter() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"filter\") {\n            return null;\n        }\n        const address = comps[1];\n        const topics = deserializeTopics(comps[2]);\n        const filter = {};\n        if (topics.length > 0) {\n            filter.topics = topics;\n        }\n        if (address && address !== \"*\") {\n            filter.address = address;\n        }\n        return filter;\n    }\n    pollable() {\n        return (this.tag.indexOf(\":\") >= 0 || PollableEvents.indexOf(this.tag) >= 0);\n    }\n}\n;\n// https://github.com/satoshilabs/slips/blob/master/slip-0044.md\nconst coinInfos = {\n    \"0\": { symbol: \"btc\", p2pkh: 0x00, p2sh: 0x05, prefix: \"bc\" },\n    \"2\": { symbol: \"ltc\", p2pkh: 0x30, p2sh: 0x32, prefix: \"ltc\" },\n    \"3\": { symbol: \"doge\", p2pkh: 0x1e, p2sh: 0x16 },\n    \"60\": { symbol: \"eth\", ilk: \"eth\" },\n    \"61\": { symbol: \"etc\", ilk: \"eth\" },\n    \"700\": { symbol: \"xdai\", ilk: \"eth\" },\n};\nfunction bytes32ify(value) {\n    return hexZeroPad(BigNumber.from(value).toHexString(), 32);\n}\n// Compute the Base58Check encoded data (checksum is first 4 bytes of sha256d)\nfunction base58Encode(data) {\n    return Base58.encode(concat([data, hexDataSlice(sha256(sha256(data)), 0, 4)]));\n}\nexport class Resolver {\n    constructor(provider, address, name) {\n        defineReadOnly(this, \"provider\", provider);\n        defineReadOnly(this, \"name\", name);\n        defineReadOnly(this, \"address\", provider.formatter.address(address));\n    }\n    _fetchBytes(selector, parameters) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // keccak256(\"addr(bytes32,uint256)\")\n            const transaction = {\n                to: this.address,\n                data: hexConcat([selector, namehash(this.name), (parameters || \"0x\")])\n            };\n            try {\n                const result = yield this.provider.call(transaction);\n                if (result === \"0x\") {\n                    return null;\n                }\n                const offset = BigNumber.from(hexDataSlice(result, 0, 32)).toNumber();\n                const length = BigNumber.from(hexDataSlice(result, offset, offset + 32)).toNumber();\n                return hexDataSlice(result, offset + 32, offset + 32 + length);\n            }\n            catch (error) {\n                if (error.code === Logger.errors.CALL_EXCEPTION) {\n                    return null;\n                }\n                return null;\n            }\n        });\n    }\n    _getAddress(coinType, hexBytes) {\n        const coinInfo = coinInfos[String(coinType)];\n        if (coinInfo == null) {\n            logger.throwError(`unsupported coin type: ${coinType}`, Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `getAddress(${coinType})`\n            });\n        }\n        if (coinInfo.ilk === \"eth\") {\n            return this.provider.formatter.address(hexBytes);\n        }\n        const bytes = arrayify(hexBytes);\n        // P2PKH: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG\n        if (coinInfo.p2pkh != null) {\n            const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);\n            if (p2pkh) {\n                const length = parseInt(p2pkh[1], 16);\n                if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode(concat([[coinInfo.p2pkh], (\"0x\" + p2pkh[2])]));\n                }\n            }\n        }\n        // P2SH: OP_HASH160 <scriptHash> OP_EQUAL\n        if (coinInfo.p2sh != null) {\n            const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);\n            if (p2sh) {\n                const length = parseInt(p2sh[1], 16);\n                if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode(concat([[coinInfo.p2sh], (\"0x\" + p2sh[2])]));\n                }\n            }\n        }\n        // Bech32\n        if (coinInfo.prefix != null) {\n            const length = bytes[1];\n            // https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#witness-program\n            let version = bytes[0];\n            if (version === 0x00) {\n                if (length !== 20 && length !== 32) {\n                    version = -1;\n                }\n            }\n            else {\n                version = -1;\n            }\n            if (version >= 0 && bytes.length === 2 + length && length >= 1 && length <= 75) {\n                const words = bech32.toWords(bytes.slice(2));\n                words.unshift(version);\n                return bech32.encode(coinInfo.prefix, words);\n            }\n        }\n        return null;\n    }\n    getAddress(coinType) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (coinType == null) {\n                coinType = 60;\n            }\n            // If Ethereum, use the standard `addr(bytes32)`\n            if (coinType === 60) {\n                try {\n                    // keccak256(\"addr(bytes32)\")\n                    const transaction = {\n                        to: this.address,\n                        data: (\"0x3b3b57de\" + namehash(this.name).substring(2))\n                    };\n                    const hexBytes = yield this.provider.call(transaction);\n                    // No address\n                    if (hexBytes === \"0x\" || hexBytes === HashZero) {\n                        return null;\n                    }\n                    return this.provider.formatter.callAddress(hexBytes);\n                }\n                catch (error) {\n                    if (error.code === Logger.errors.CALL_EXCEPTION) {\n                        return null;\n                    }\n                    throw error;\n                }\n            }\n            // keccak256(\"addr(bytes32,uint256\")\n            const hexBytes = yield this._fetchBytes(\"0xf1cb7e06\", bytes32ify(coinType));\n            // No address\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            // Compute the address\n            const address = this._getAddress(coinType, hexBytes);\n            if (address == null) {\n                logger.throwError(`invalid or unsupported coin data`, Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: `getAddress(${coinType})`,\n                    coinType: coinType,\n                    data: hexBytes\n                });\n            }\n            return address;\n        });\n    }\n    getContentHash() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // keccak256(\"contenthash()\")\n            const hexBytes = yield this._fetchBytes(\"0xbc1c58d1\");\n            // No contenthash\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            // IPFS (CID: 1, Type: DAG-PB)\n            const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n            if (ipfs) {\n                const length = parseInt(ipfs[3], 16);\n                if (ipfs[4].length === length * 2) {\n                    return \"ipfs:/\\/\" + Base58.encode(\"0x\" + ipfs[1]);\n                }\n            }\n            // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)\n            const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);\n            if (swarm) {\n                if (swarm[1].length === (32 * 2)) {\n                    return \"bzz:/\\/\" + swarm[1];\n                }\n            }\n            return logger.throwError(`invalid or unsupported content hash data`, Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"getContentHash()\",\n                data: hexBytes\n            });\n        });\n    }\n    getText(key) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // The key encoded as parameter to fetchBytes\n            let keyBytes = toUtf8Bytes(key);\n            // The nodehash consumes the first slot, so the string pointer targets\n            // offset 64, with the length at offset 64 and data starting at offset 96\n            keyBytes = concat([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]);\n            // Pad to word-size (32 bytes)\n            if ((keyBytes.length % 32) !== 0) {\n                keyBytes = concat([keyBytes, hexZeroPad(\"0x\", 32 - (key.length % 32))]);\n            }\n            const hexBytes = yield this._fetchBytes(\"0x59d1d43c\", hexlify(keyBytes));\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            return toUtf8String(hexBytes);\n        });\n    }\n}\nlet defaultFormatter = null;\nlet nextPollId = 1;\nexport class BaseProvider extends Provider {\n    /**\n     *  ready\n     *\n     *  A Promise<Network> that resolves only once the provider is ready.\n     *\n     *  Sub-classes that call the super with a network without a chainId\n     *  MUST set this. Standard named networks have a known chainId.\n     *\n     */\n    constructor(network) {\n        logger.checkNew(new.target, Provider);\n        super();\n        // Events being listened to\n        this._events = [];\n        this._emitted = { block: -2 };\n        this.formatter = new.target.getFormatter();\n        // If network is any, this Provider allows the underlying\n        // network to change dynamically, and we auto-detect the\n        // current network\n        defineReadOnly(this, \"anyNetwork\", (network === \"any\"));\n        if (this.anyNetwork) {\n            network = this.detectNetwork();\n        }\n        if (network instanceof Promise) {\n            this._networkPromise = network;\n            // Squash any \"unhandled promise\" errors; that do not need to be handled\n            network.catch((error) => { });\n            // Trigger initial network setting (async)\n            this._ready().catch((error) => { });\n        }\n        else {\n            const knownNetwork = getStatic((new.target), \"getNetwork\")(network);\n            if (knownNetwork) {\n                defineReadOnly(this, \"_network\", knownNetwork);\n                this.emit(\"network\", knownNetwork, null);\n            }\n            else {\n                logger.throwArgumentError(\"invalid network\", \"network\", network);\n            }\n        }\n        this._maxInternalBlockNumber = -1024;\n        this._lastBlockNumber = -2;\n        this._pollingInterval = 4000;\n        this._fastQueryDate = 0;\n    }\n    _ready() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._network == null) {\n                let network = null;\n                if (this._networkPromise) {\n                    try {\n                        network = yield this._networkPromise;\n                    }\n                    catch (error) { }\n                }\n                // Try the Provider's network detection (this MUST throw if it cannot)\n                if (network == null) {\n                    network = yield this.detectNetwork();\n                }\n                // This should never happen; every Provider sub-class should have\n                // suggested a network by here (or have thrown).\n                if (!network) {\n                    logger.throwError(\"no network detected\", Logger.errors.UNKNOWN_ERROR, {});\n                }\n                // Possible this call stacked so do not call defineReadOnly again\n                if (this._network == null) {\n                    if (this.anyNetwork) {\n                        this._network = network;\n                    }\n                    else {\n                        defineReadOnly(this, \"_network\", network);\n                    }\n                    this.emit(\"network\", network, null);\n                }\n            }\n            return this._network;\n        });\n    }\n    // This will always return the most recently established network.\n    // For \"any\", this can change (a \"network\" event is emitted before\n    // any change is refelcted); otherwise this cannot change\n    get ready() {\n        return poll(() => {\n            return this._ready().then((network) => {\n                return network;\n            }, (error) => {\n                // If the network isn't running yet, we will wait\n                if (error.code === Logger.errors.NETWORK_ERROR && error.event === \"noNetwork\") {\n                    return undefined;\n                }\n                throw error;\n            });\n        });\n    }\n    // @TODO: Remove this and just create a singleton formatter\n    static getFormatter() {\n        if (defaultFormatter == null) {\n            defaultFormatter = new Formatter();\n        }\n        return defaultFormatter;\n    }\n    // @TODO: Remove this and just use getNetwork\n    static getNetwork(network) {\n        return getNetwork((network == null) ? \"homestead\" : network);\n    }\n    // Fetches the blockNumber, but will reuse any result that is less\n    // than maxAge old or has been requested since the last request\n    _getInternalBlockNumber(maxAge) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this._ready();\n            // Allowing stale data up to maxAge old\n            if (maxAge > 0) {\n                // While there are pending internal block requests...\n                while (this._internalBlockNumber) {\n                    // ...\"remember\" which fetch we started with\n                    const internalBlockNumber = this._internalBlockNumber;\n                    try {\n                        // Check the result is not too stale\n                        const result = yield internalBlockNumber;\n                        if ((getTime() - result.respTime) <= maxAge) {\n                            return result.blockNumber;\n                        }\n                        // Too old; fetch a new value\n                        break;\n                    }\n                    catch (error) {\n                        // The fetch rejected; if we are the first to get the\n                        // rejection, drop through so we replace it with a new\n                        // fetch; all others blocked will then get that fetch\n                        // which won't match the one they \"remembered\" and loop\n                        if (this._internalBlockNumber === internalBlockNumber) {\n                            break;\n                        }\n                    }\n                }\n            }\n            const reqTime = getTime();\n            const checkInternalBlockNumber = resolveProperties({\n                blockNumber: this.perform(\"getBlockNumber\", {}),\n                networkError: this.getNetwork().then((network) => (null), (error) => (error))\n            }).then(({ blockNumber, networkError }) => {\n                if (networkError) {\n                    // Unremember this bad internal block number\n                    if (this._internalBlockNumber === checkInternalBlockNumber) {\n                        this._internalBlockNumber = null;\n                    }\n                    throw networkError;\n                }\n                const respTime = getTime();\n                blockNumber = BigNumber.from(blockNumber).toNumber();\n                if (blockNumber < this._maxInternalBlockNumber) {\n                    blockNumber = this._maxInternalBlockNumber;\n                }\n                this._maxInternalBlockNumber = blockNumber;\n                this._setFastBlockNumber(blockNumber); // @TODO: Still need this?\n                return { blockNumber, reqTime, respTime };\n            });\n            this._internalBlockNumber = checkInternalBlockNumber;\n            // Swallow unhandled exceptions; if needed they are handled else where\n            checkInternalBlockNumber.catch((error) => {\n                // Don't null the dead (rejected) fetch, if it has already been updated\n                if (this._internalBlockNumber === checkInternalBlockNumber) {\n                    this._internalBlockNumber = null;\n                }\n            });\n            return (yield checkInternalBlockNumber).blockNumber;\n        });\n    }\n    poll() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const pollId = nextPollId++;\n            // Track all running promises, so we can trigger a post-poll once they are complete\n            const runners = [];\n            let blockNumber = null;\n            try {\n                blockNumber = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);\n            }\n            catch (error) {\n                this.emit(\"error\", error);\n                return;\n            }\n            this._setFastBlockNumber(blockNumber);\n            // Emit a poll event after we have the latest (fast) block number\n            this.emit(\"poll\", pollId, blockNumber);\n            // If the block has not changed, meh.\n            if (blockNumber === this._lastBlockNumber) {\n                this.emit(\"didPoll\", pollId);\n                return;\n            }\n            // First polling cycle, trigger a \"block\" events\n            if (this._emitted.block === -2) {\n                this._emitted.block = blockNumber - 1;\n            }\n            if (Math.abs((this._emitted.block) - blockNumber) > 1000) {\n                logger.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${blockNumber})`);\n                this.emit(\"error\", logger.makeError(\"network block skew detected\", Logger.errors.NETWORK_ERROR, {\n                    blockNumber: blockNumber,\n                    event: \"blockSkew\",\n                    previousBlockNumber: this._emitted.block\n                }));\n                this.emit(\"block\", blockNumber);\n            }\n            else {\n                // Notify all listener for each block that has passed\n                for (let i = this._emitted.block + 1; i <= blockNumber; i++) {\n                    this.emit(\"block\", i);\n                }\n            }\n            // The emitted block was updated, check for obsolete events\n            if (this._emitted.block !== blockNumber) {\n                this._emitted.block = blockNumber;\n                Object.keys(this._emitted).forEach((key) => {\n                    // The block event does not expire\n                    if (key === \"block\") {\n                        return;\n                    }\n                    // The block we were at when we emitted this event\n                    const eventBlockNumber = this._emitted[key];\n                    // We cannot garbage collect pending transactions or blocks here\n                    // They should be garbage collected by the Provider when setting\n                    // \"pending\" events\n                    if (eventBlockNumber === \"pending\") {\n                        return;\n                    }\n                    // Evict any transaction hashes or block hashes over 12 blocks\n                    // old, since they should not return null anyways\n                    if (blockNumber - eventBlockNumber > 12) {\n                        delete this._emitted[key];\n                    }\n                });\n            }\n            // First polling cycle\n            if (this._lastBlockNumber === -2) {\n                this._lastBlockNumber = blockNumber - 1;\n            }\n            // Find all transaction hashes we are waiting on\n            this._events.forEach((event) => {\n                switch (event.type) {\n                    case \"tx\": {\n                        const hash = event.hash;\n                        let runner = this.getTransactionReceipt(hash).then((receipt) => {\n                            if (!receipt || receipt.blockNumber == null) {\n                                return null;\n                            }\n                            this._emitted[\"t:\" + hash] = receipt.blockNumber;\n                            this.emit(hash, receipt);\n                            return null;\n                        }).catch((error) => { this.emit(\"error\", error); });\n                        runners.push(runner);\n                        break;\n                    }\n                    case \"filter\": {\n                        const filter = event.filter;\n                        filter.fromBlock = this._lastBlockNumber + 1;\n                        filter.toBlock = blockNumber;\n                        const runner = this.getLogs(filter).then((logs) => {\n                            if (logs.length === 0) {\n                                return;\n                            }\n                            logs.forEach((log) => {\n                                this._emitted[\"b:\" + log.blockHash] = log.blockNumber;\n                                this._emitted[\"t:\" + log.transactionHash] = log.blockNumber;\n                                this.emit(filter, log);\n                            });\n                        }).catch((error) => { this.emit(\"error\", error); });\n                        runners.push(runner);\n                        break;\n                    }\n                }\n            });\n            this._lastBlockNumber = blockNumber;\n            // Once all events for this loop have been processed, emit \"didPoll\"\n            Promise.all(runners).then(() => {\n                this.emit(\"didPoll\", pollId);\n            }).catch((error) => { this.emit(\"error\", error); });\n            return;\n        });\n    }\n    // Deprecated; do not use this\n    resetEventsBlock(blockNumber) {\n        this._lastBlockNumber = blockNumber - 1;\n        if (this.polling) {\n            this.poll();\n        }\n    }\n    get network() {\n        return this._network;\n    }\n    // This method should query the network if the underlying network\n    // can change, such as when connected to a JSON-RPC backend\n    detectNetwork() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return logger.throwError(\"provider does not support network detection\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"provider.detectNetwork\"\n            });\n        });\n    }\n    getNetwork() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const network = yield this._ready();\n            // Make sure we are still connected to the same network; this is\n            // only an external call for backends which can have the underlying\n            // network change spontaneously\n            const currentNetwork = yield this.detectNetwork();\n            if (network.chainId !== currentNetwork.chainId) {\n                // We are allowing network changes, things can get complex fast;\n                // make sure you know what you are doing if you use \"any\"\n                if (this.anyNetwork) {\n                    this._network = currentNetwork;\n                    // Reset all internal block number guards and caches\n                    this._lastBlockNumber = -2;\n                    this._fastBlockNumber = null;\n                    this._fastBlockNumberPromise = null;\n                    this._fastQueryDate = 0;\n                    this._emitted.block = -2;\n                    this._maxInternalBlockNumber = -1024;\n                    this._internalBlockNumber = null;\n                    // The \"network\" event MUST happen before this method resolves\n                    // so any events have a chance to unregister, so we stall an\n                    // additional event loop before returning from /this/ call\n                    this.emit(\"network\", currentNetwork, network);\n                    yield stall(0);\n                    return this._network;\n                }\n                const error = logger.makeError(\"underlying network changed\", Logger.errors.NETWORK_ERROR, {\n                    event: \"changed\",\n                    network: network,\n                    detectedNetwork: currentNetwork\n                });\n                this.emit(\"error\", error);\n                throw error;\n            }\n            return network;\n        });\n    }\n    get blockNumber() {\n        this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {\n            this._setFastBlockNumber(blockNumber);\n        }, (error) => { });\n        return (this._fastBlockNumber != null) ? this._fastBlockNumber : -1;\n    }\n    get polling() {\n        return (this._poller != null);\n    }\n    set polling(value) {\n        if (value && !this._poller) {\n            this._poller = setInterval(() => { this.poll(); }, this.pollingInterval);\n            if (!this._bootstrapPoll) {\n                this._bootstrapPoll = setTimeout(() => {\n                    this.poll();\n                    // We block additional polls until the polling interval\n                    // is done, to prevent overwhelming the poll function\n                    this._bootstrapPoll = setTimeout(() => {\n                        // If polling was disabled, something may require a poke\n                        // since starting the bootstrap poll and it was disabled\n                        if (!this._poller) {\n                            this.poll();\n                        }\n                        // Clear out the bootstrap so we can do another\n                        this._bootstrapPoll = null;\n                    }, this.pollingInterval);\n                }, 0);\n            }\n        }\n        else if (!value && this._poller) {\n            clearInterval(this._poller);\n            this._poller = null;\n        }\n    }\n    get pollingInterval() {\n        return this._pollingInterval;\n    }\n    set pollingInterval(value) {\n        if (typeof (value) !== \"number\" || value <= 0 || parseInt(String(value)) != value) {\n            throw new Error(\"invalid polling interval\");\n        }\n        this._pollingInterval = value;\n        if (this._poller) {\n            clearInterval(this._poller);\n            this._poller = setInterval(() => { this.poll(); }, this._pollingInterval);\n        }\n    }\n    _getFastBlockNumber() {\n        const now = getTime();\n        // Stale block number, request a newer value\n        if ((now - this._fastQueryDate) > 2 * this._pollingInterval) {\n            this._fastQueryDate = now;\n            this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {\n                if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n                    this._fastBlockNumber = blockNumber;\n                }\n                return this._fastBlockNumber;\n            });\n        }\n        return this._fastBlockNumberPromise;\n    }\n    _setFastBlockNumber(blockNumber) {\n        // Older block, maybe a stale request\n        if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {\n            return;\n        }\n        // Update the time we updated the blocknumber\n        this._fastQueryDate = getTime();\n        // Newer block number, use  it\n        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n            this._fastBlockNumber = blockNumber;\n            this._fastBlockNumberPromise = Promise.resolve(blockNumber);\n        }\n    }\n    waitForTransaction(transactionHash, confirmations, timeout) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this._waitForTransaction(transactionHash, (confirmations == null) ? 1 : confirmations, timeout || 0, null);\n        });\n    }\n    _waitForTransaction(transactionHash, confirmations, timeout, replaceable) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const receipt = yield this.getTransactionReceipt(transactionHash);\n            // Receipt is already good\n            if ((receipt ? receipt.confirmations : 0) >= confirmations) {\n                return receipt;\n            }\n            // Poll until the receipt is good...\n            return new Promise((resolve, reject) => {\n                const cancelFuncs = [];\n                let done = false;\n                const alreadyDone = function () {\n                    if (done) {\n                        return true;\n                    }\n                    done = true;\n                    cancelFuncs.forEach((func) => { func(); });\n                    return false;\n                };\n                const minedHandler = (receipt) => {\n                    if (receipt.confirmations < confirmations) {\n                        return;\n                    }\n                    if (alreadyDone()) {\n                        return;\n                    }\n                    resolve(receipt);\n                };\n                this.on(transactionHash, minedHandler);\n                cancelFuncs.push(() => { this.removeListener(transactionHash, minedHandler); });\n                if (replaceable) {\n                    let lastBlockNumber = replaceable.startBlock;\n                    let scannedBlock = null;\n                    const replaceHandler = (blockNumber) => __awaiter(this, void 0, void 0, function* () {\n                        if (done) {\n                            return;\n                        }\n                        // Wait 1 second; this is only used in the case of a fault, so\n                        // we will trade off a little bit of latency for more consistent\n                        // results and fewer JSON-RPC calls\n                        yield stall(1000);\n                        this.getTransactionCount(replaceable.from).then((nonce) => __awaiter(this, void 0, void 0, function* () {\n                            if (done) {\n                                return;\n                            }\n                            if (nonce <= replaceable.nonce) {\n                                lastBlockNumber = blockNumber;\n                            }\n                            else {\n                                // First check if the transaction was mined\n                                {\n                                    const mined = yield this.getTransaction(transactionHash);\n                                    if (mined && mined.blockNumber != null) {\n                                        return;\n                                    }\n                                }\n                                // First time scanning. We start a little earlier for some\n                                // wiggle room here to handle the eventually consistent nature\n                                // of blockchain (e.g. the getTransactionCount was for a\n                                // different block)\n                                if (scannedBlock == null) {\n                                    scannedBlock = lastBlockNumber - 3;\n                                    if (scannedBlock < replaceable.startBlock) {\n                                        scannedBlock = replaceable.startBlock;\n                                    }\n                                }\n                                while (scannedBlock <= blockNumber) {\n                                    if (done) {\n                                        return;\n                                    }\n                                    const block = yield this.getBlockWithTransactions(scannedBlock);\n                                    for (let ti = 0; ti < block.transactions.length; ti++) {\n                                        const tx = block.transactions[ti];\n                                        // Successfully mined!\n                                        if (tx.hash === transactionHash) {\n                                            return;\n                                        }\n                                        // Matches our transaction from and nonce; its a replacement\n                                        if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {\n                                            if (done) {\n                                                return;\n                                            }\n                                            // Get the receipt of the replacement\n                                            const receipt = yield this.waitForTransaction(tx.hash, confirmations);\n                                            // Already resolved or rejected (prolly a timeout)\n                                            if (alreadyDone()) {\n                                                return;\n                                            }\n                                            // The reason we were replaced\n                                            let reason = \"replaced\";\n                                            if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {\n                                                reason = \"repriced\";\n                                            }\n                                            else if (tx.data === \"0x\" && tx.from === tx.to && tx.value.isZero()) {\n                                                reason = \"cancelled\";\n                                            }\n                                            // Explain why we were replaced\n                                            reject(logger.makeError(\"transaction was replaced\", Logger.errors.TRANSACTION_REPLACED, {\n                                                cancelled: (reason === \"replaced\" || reason === \"cancelled\"),\n                                                reason,\n                                                replacement: this._wrapTransaction(tx),\n                                                hash: transactionHash,\n                                                receipt\n                                            }));\n                                            return;\n                                        }\n                                    }\n                                    scannedBlock++;\n                                }\n                            }\n                            if (done) {\n                                return;\n                            }\n                            this.once(\"block\", replaceHandler);\n                        }), (error) => {\n                            if (done) {\n                                return;\n                            }\n                            this.once(\"block\", replaceHandler);\n                        });\n                    });\n                    if (done) {\n                        return;\n                    }\n                    this.once(\"block\", replaceHandler);\n                    cancelFuncs.push(() => {\n                        this.removeListener(\"block\", replaceHandler);\n                    });\n                }\n                if (typeof (timeout) === \"number\" && timeout > 0) {\n                    const timer = setTimeout(() => {\n                        if (alreadyDone()) {\n                            return;\n                        }\n                        reject(logger.makeError(\"timeout exceeded\", Logger.errors.TIMEOUT, { timeout: timeout }));\n                    }, timeout);\n                    if (timer.unref) {\n                        timer.unref();\n                    }\n                    cancelFuncs.push(() => { clearTimeout(timer); });\n                }\n            });\n        });\n    }\n    getBlockNumber() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this._getInternalBlockNumber(0);\n        });\n    }\n    getGasPrice() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const result = yield this.perform(\"getGasPrice\", {});\n            try {\n                return BigNumber.from(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getGasPrice\",\n                    result, error\n                });\n            }\n        });\n    }\n    getBalance(addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getBalance\", params);\n            try {\n                return BigNumber.from(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getBalance\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    getTransactionCount(addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getTransactionCount\", params);\n            try {\n                return BigNumber.from(result).toNumber();\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getTransactionCount\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    getCode(addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getCode\", params);\n            try {\n                return hexlify(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getCode\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    getStorageAt(addressOrName, position, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag),\n                position: Promise.resolve(position).then((p) => hexValue(p))\n            });\n            const result = yield this.perform(\"getStorageAt\", params);\n            try {\n                return hexlify(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getStorageAt\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    // This should be called by any subclass wrapping a TransactionResponse\n    _wrapTransaction(tx, hash, startBlock) {\n        if (hash != null && hexDataLength(hash) !== 32) {\n            throw new Error(\"invalid response - sendTransaction\");\n        }\n        const result = tx;\n        // Check the hash we expect is the same as the hash the server reported\n        if (hash != null && tx.hash !== hash) {\n            logger.throwError(\"Transaction hash mismatch from Provider.sendTransaction.\", Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash });\n        }\n        result.wait = (confirms, timeout) => __awaiter(this, void 0, void 0, function* () {\n            if (confirms == null) {\n                confirms = 1;\n            }\n            if (timeout == null) {\n                timeout = 0;\n            }\n            // Get the details to detect replacement\n            let replacement = undefined;\n            if (confirms !== 0 && startBlock != null) {\n                replacement = {\n                    data: tx.data,\n                    from: tx.from,\n                    nonce: tx.nonce,\n                    to: tx.to,\n                    value: tx.value,\n                    startBlock\n                };\n            }\n            const receipt = yield this._waitForTransaction(tx.hash, confirms, timeout, replacement);\n            if (receipt == null && confirms === 0) {\n                return null;\n            }\n            // No longer pending, allow the polling loop to garbage collect this\n            this._emitted[\"t:\" + tx.hash] = receipt.blockNumber;\n            if (receipt.status === 0) {\n                logger.throwError(\"transaction failed\", Logger.errors.CALL_EXCEPTION, {\n                    transactionHash: tx.hash,\n                    transaction: tx,\n                    receipt: receipt\n                });\n            }\n            return receipt;\n        });\n        return result;\n    }\n    sendTransaction(signedTransaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const hexTx = yield Promise.resolve(signedTransaction).then(t => hexlify(t));\n            const tx = this.formatter.transaction(signedTransaction);\n            if (tx.confirmations == null) {\n                tx.confirmations = 0;\n            }\n            const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n            try {\n                const hash = yield this.perform(\"sendTransaction\", { signedTransaction: hexTx });\n                return this._wrapTransaction(tx, hash, blockNumber);\n            }\n            catch (error) {\n                error.transaction = tx;\n                error.transactionHash = tx.hash;\n                throw error;\n            }\n        });\n    }\n    _getTransactionRequest(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const values = yield transaction;\n            const tx = {};\n            [\"from\", \"to\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => (v ? this._getAddress(v) : null));\n            });\n            [\"gasLimit\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"value\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => (v ? BigNumber.from(v) : null));\n            });\n            [\"type\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => ((v != null) ? v : null));\n            });\n            if (values.accessList) {\n                tx.accessList = this.formatter.accessList(values.accessList);\n            }\n            [\"data\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => (v ? hexlify(v) : null));\n            });\n            return this.formatter.transactionRequest(yield resolveProperties(tx));\n        });\n    }\n    _getFilter(filter) {\n        return __awaiter(this, void 0, void 0, function* () {\n            filter = yield filter;\n            const result = {};\n            if (filter.address != null) {\n                result.address = this._getAddress(filter.address);\n            }\n            [\"blockHash\", \"topics\"].forEach((key) => {\n                if (filter[key] == null) {\n                    return;\n                }\n                result[key] = filter[key];\n            });\n            [\"fromBlock\", \"toBlock\"].forEach((key) => {\n                if (filter[key] == null) {\n                    return;\n                }\n                result[key] = this._getBlockTag(filter[key]);\n            });\n            return this.formatter.filter(yield resolveProperties(result));\n        });\n    }\n    call(transaction, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                transaction: this._getTransactionRequest(transaction),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"call\", params);\n            try {\n                return hexlify(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"call\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    estimateGas(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                transaction: this._getTransactionRequest(transaction)\n            });\n            const result = yield this.perform(\"estimateGas\", params);\n            try {\n                return BigNumber.from(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"estimateGas\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    _getAddress(addressOrName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const address = yield this.resolveName(addressOrName);\n            if (address == null) {\n                logger.throwError(\"ENS name not configured\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: `resolveName(${JSON.stringify(addressOrName)})`\n                });\n            }\n            return address;\n        });\n    }\n    _getBlock(blockHashOrBlockTag, includeTransactions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            blockHashOrBlockTag = yield blockHashOrBlockTag;\n            // If blockTag is a number (not \"latest\", etc), this is the block number\n            let blockNumber = -128;\n            const params = {\n                includeTransactions: !!includeTransactions\n            };\n            if (isHexString(blockHashOrBlockTag, 32)) {\n                params.blockHash = blockHashOrBlockTag;\n            }\n            else {\n                try {\n                    params.blockTag = this.formatter.blockTag(yield this._getBlockTag(blockHashOrBlockTag));\n                    if (isHexString(params.blockTag)) {\n                        blockNumber = parseInt(params.blockTag.substring(2), 16);\n                    }\n                }\n                catch (error) {\n                    logger.throwArgumentError(\"invalid block hash or block tag\", \"blockHashOrBlockTag\", blockHashOrBlockTag);\n                }\n            }\n            return poll(() => __awaiter(this, void 0, void 0, function* () {\n                const block = yield this.perform(\"getBlock\", params);\n                // Block was not found\n                if (block == null) {\n                    // For blockhashes, if we didn't say it existed, that blockhash may\n                    // not exist. If we did see it though, perhaps from a log, we know\n                    // it exists, and this node is just not caught up yet.\n                    if (params.blockHash != null) {\n                        if (this._emitted[\"b:\" + params.blockHash] == null) {\n                            return null;\n                        }\n                    }\n                    // For block tags, if we are asking for a future block, we return null\n                    if (params.blockTag != null) {\n                        if (blockNumber > this._emitted.block) {\n                            return null;\n                        }\n                    }\n                    // Retry on the next block\n                    return undefined;\n                }\n                // Add transactions\n                if (includeTransactions) {\n                    let blockNumber = null;\n                    for (let i = 0; i < block.transactions.length; i++) {\n                        const tx = block.transactions[i];\n                        if (tx.blockNumber == null) {\n                            tx.confirmations = 0;\n                        }\n                        else if (tx.confirmations == null) {\n                            if (blockNumber == null) {\n                                blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                            }\n                            // Add the confirmations using the fast block number (pessimistic)\n                            let confirmations = (blockNumber - tx.blockNumber) + 1;\n                            if (confirmations <= 0) {\n                                confirmations = 1;\n                            }\n                            tx.confirmations = confirmations;\n                        }\n                    }\n                    const blockWithTxs = this.formatter.blockWithTransactions(block);\n                    blockWithTxs.transactions = blockWithTxs.transactions.map((tx) => this._wrapTransaction(tx));\n                    return blockWithTxs;\n                }\n                return this.formatter.block(block);\n            }), { oncePoll: this });\n        });\n    }\n    getBlock(blockHashOrBlockTag) {\n        return (this._getBlock(blockHashOrBlockTag, false));\n    }\n    getBlockWithTransactions(blockHashOrBlockTag) {\n        return (this._getBlock(blockHashOrBlockTag, true));\n    }\n    getTransaction(transactionHash) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            transactionHash = yield transactionHash;\n            const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n            return poll(() => __awaiter(this, void 0, void 0, function* () {\n                const result = yield this.perform(\"getTransaction\", params);\n                if (result == null) {\n                    if (this._emitted[\"t:\" + transactionHash] == null) {\n                        return null;\n                    }\n                    return undefined;\n                }\n                const tx = this.formatter.transactionResponse(result);\n                if (tx.blockNumber == null) {\n                    tx.confirmations = 0;\n                }\n                else if (tx.confirmations == null) {\n                    const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                    // Add the confirmations using the fast block number (pessimistic)\n                    let confirmations = (blockNumber - tx.blockNumber) + 1;\n                    if (confirmations <= 0) {\n                        confirmations = 1;\n                    }\n                    tx.confirmations = confirmations;\n                }\n                return this._wrapTransaction(tx);\n            }), { oncePoll: this });\n        });\n    }\n    getTransactionReceipt(transactionHash) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            transactionHash = yield transactionHash;\n            const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n            return poll(() => __awaiter(this, void 0, void 0, function* () {\n                const result = yield this.perform(\"getTransactionReceipt\", params);\n                if (result == null) {\n                    if (this._emitted[\"t:\" + transactionHash] == null) {\n                        return null;\n                    }\n                    return undefined;\n                }\n                // \"geth-etc\" returns receipts before they are ready\n                if (result.blockHash == null) {\n                    return undefined;\n                }\n                const receipt = this.formatter.receipt(result);\n                if (receipt.blockNumber == null) {\n                    receipt.confirmations = 0;\n                }\n                else if (receipt.confirmations == null) {\n                    const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                    // Add the confirmations using the fast block number (pessimistic)\n                    let confirmations = (blockNumber - receipt.blockNumber) + 1;\n                    if (confirmations <= 0) {\n                        confirmations = 1;\n                    }\n                    receipt.confirmations = confirmations;\n                }\n                return receipt;\n            }), { oncePoll: this });\n        });\n    }\n    getLogs(filter) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({ filter: this._getFilter(filter) });\n            const logs = yield this.perform(\"getLogs\", params);\n            logs.forEach((log) => {\n                if (log.removed == null) {\n                    log.removed = false;\n                }\n            });\n            return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);\n        });\n    }\n    getEtherPrice() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            return this.perform(\"getEtherPrice\", {});\n        });\n    }\n    _getBlockTag(blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            blockTag = yield blockTag;\n            if (typeof (blockTag) === \"number\" && blockTag < 0) {\n                if (blockTag % 1) {\n                    logger.throwArgumentError(\"invalid BlockTag\", \"blockTag\", blockTag);\n                }\n                let blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                blockNumber += blockTag;\n                if (blockNumber < 0) {\n                    blockNumber = 0;\n                }\n                return this.formatter.blockTag(blockNumber);\n            }\n            return this.formatter.blockTag(blockTag);\n        });\n    }\n    getResolver(name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const address = yield this._getResolver(name);\n                if (address == null) {\n                    return null;\n                }\n                return new Resolver(this, address, name);\n            }\n            catch (error) {\n                if (error.code === Logger.errors.CALL_EXCEPTION) {\n                    return null;\n                }\n                return null;\n            }\n        });\n    }\n    _getResolver(name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Get the resolver from the blockchain\n            const network = yield this.getNetwork();\n            // No ENS...\n            if (!network.ensAddress) {\n                logger.throwError(\"network does not support ENS\", Logger.errors.UNSUPPORTED_OPERATION, { operation: \"ENS\", network: network.name });\n            }\n            // keccak256(\"resolver(bytes32)\")\n            const transaction = {\n                to: network.ensAddress,\n                data: (\"0x0178b8bf\" + namehash(name).substring(2))\n            };\n            try {\n                return this.formatter.callAddress(yield this.call(transaction));\n            }\n            catch (error) {\n                if (error.code === Logger.errors.CALL_EXCEPTION) {\n                    return null;\n                }\n                throw error;\n            }\n        });\n    }\n    resolveName(name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            name = yield name;\n            // If it is already an address, nothing to resolve\n            try {\n                return Promise.resolve(this.formatter.address(name));\n            }\n            catch (error) {\n                // If is is a hexstring, the address is bad (See #694)\n                if (isHexString(name)) {\n                    throw error;\n                }\n            }\n            if (typeof (name) !== \"string\") {\n                logger.throwArgumentError(\"invalid ENS name\", \"name\", name);\n            }\n            // Get the addr from the resovler\n            const resolver = yield this.getResolver(name);\n            if (!resolver) {\n                return null;\n            }\n            return yield resolver.getAddress();\n        });\n    }\n    lookupAddress(address) {\n        return __awaiter(this, void 0, void 0, function* () {\n            address = yield address;\n            address = this.formatter.address(address);\n            const reverseName = address.substring(2).toLowerCase() + \".addr.reverse\";\n            const resolverAddress = yield this._getResolver(reverseName);\n            if (!resolverAddress) {\n                return null;\n            }\n            // keccak(\"name(bytes32)\")\n            let bytes = arrayify(yield this.call({\n                to: resolverAddress,\n                data: (\"0x691f3431\" + namehash(reverseName).substring(2))\n            }));\n            // Strip off the dynamic string pointer (0x20)\n            if (bytes.length < 32 || !BigNumber.from(bytes.slice(0, 32)).eq(32)) {\n                return null;\n            }\n            bytes = bytes.slice(32);\n            // Not a length-prefixed string\n            if (bytes.length < 32) {\n                return null;\n            }\n            // Get the length of the string (from the length-prefix)\n            const length = BigNumber.from(bytes.slice(0, 32)).toNumber();\n            bytes = bytes.slice(32);\n            // Length longer than available data\n            if (length > bytes.length) {\n                return null;\n            }\n            const name = toUtf8String(bytes.slice(0, length));\n            // Make sure the reverse record matches the foward record\n            const addr = yield this.resolveName(name);\n            if (addr != address) {\n                return null;\n            }\n            return name;\n        });\n    }\n    perform(method, params) {\n        return logger.throwError(method + \" not implemented\", Logger.errors.NOT_IMPLEMENTED, { operation: method });\n    }\n    _startEvent(event) {\n        this.polling = (this._events.filter((e) => e.pollable()).length > 0);\n    }\n    _stopEvent(event) {\n        this.polling = (this._events.filter((e) => e.pollable()).length > 0);\n    }\n    _addEventListener(eventName, listener, once) {\n        const event = new Event(getEventTag(eventName), listener, once);\n        this._events.push(event);\n        this._startEvent(event);\n        return this;\n    }\n    on(eventName, listener) {\n        return this._addEventListener(eventName, listener, false);\n    }\n    once(eventName, listener) {\n        return this._addEventListener(eventName, listener, true);\n    }\n    emit(eventName, ...args) {\n        let result = false;\n        let stopped = [];\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event) => {\n            if (event.tag !== eventTag) {\n                return true;\n            }\n            setTimeout(() => {\n                event.listener.apply(this, args);\n            }, 0);\n            result = true;\n            if (event.once) {\n                stopped.push(event);\n                return false;\n            }\n            return true;\n        });\n        stopped.forEach((event) => { this._stopEvent(event); });\n        return result;\n    }\n    listenerCount(eventName) {\n        if (!eventName) {\n            return this._events.length;\n        }\n        let eventTag = getEventTag(eventName);\n        return this._events.filter((event) => {\n            return (event.tag === eventTag);\n        }).length;\n    }\n    listeners(eventName) {\n        if (eventName == null) {\n            return this._events.map((event) => event.listener);\n        }\n        let eventTag = getEventTag(eventName);\n        return this._events\n            .filter((event) => (event.tag === eventTag))\n            .map((event) => event.listener);\n    }\n    off(eventName, listener) {\n        if (listener == null) {\n            return this.removeAllListeners(eventName);\n        }\n        const stopped = [];\n        let found = false;\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event) => {\n            if (event.tag !== eventTag || event.listener != listener) {\n                return true;\n            }\n            if (found) {\n                return true;\n            }\n            found = true;\n            stopped.push(event);\n            return false;\n        });\n        stopped.forEach((event) => { this._stopEvent(event); });\n        return this;\n    }\n    removeAllListeners(eventName) {\n        let stopped = [];\n        if (eventName == null) {\n            stopped = this._events;\n            this._events = [];\n        }\n        else {\n            const eventTag = getEventTag(eventName);\n            this._events = this._events.filter((event) => {\n                if (event.tag !== eventTag) {\n                    return true;\n                }\n                stopped.push(event);\n                return false;\n            });\n        }\n        stopped.forEach((event) => { this._stopEvent(event); });\n        return this;\n    }\n}\n//# sourceMappingURL=base-provider.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Signer } from \"@ethersproject/abstract-signer\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { hexlify, hexValue, isHexString } from \"@ethersproject/bytes\";\nimport { _TypedDataEncoder } from \"@ethersproject/hash\";\nimport { checkProperties, deepCopy, defineReadOnly, getStatic, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\nimport { accessListify } from \"@ethersproject/transactions\";\nimport { fetchJson, poll } from \"@ethersproject/web\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { BaseProvider } from \"./base-provider\";\nconst errorGas = [\"call\", \"estimateGas\"];\nfunction checkError(method, error, params) {\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\" && error.code === Logger.errors.SERVER_ERROR) {\n        const e = error.error;\n        if (e && e.message.match(\"reverted\") && isHexString(e.data)) {\n            return e.data;\n        }\n        logger.throwError(\"missing revert data in call exception\", Logger.errors.CALL_EXCEPTION, {\n            error, data: \"0x\"\n        });\n    }\n    let message = error.message;\n    if (error.code === Logger.errors.SERVER_ERROR && error.error && typeof (error.error.message) === \"string\") {\n        message = error.error.message;\n    }\n    else if (typeof (error.body) === \"string\") {\n        message = error.body;\n    }\n    else if (typeof (error.responseText) === \"string\") {\n        message = error.responseText;\n    }\n    message = (message || \"\").toLowerCase();\n    const transaction = params.transaction || params.signedTransaction;\n    // \"insufficient funds for gas * price + value + cost(data)\"\n    if (message.match(/insufficient funds|base fee exceeds gas limit/)) {\n        logger.throwError(\"insufficient funds for intrinsic transaction cost\", Logger.errors.INSUFFICIENT_FUNDS, {\n            error, method, transaction\n        });\n    }\n    // \"nonce too low\"\n    if (message.match(/nonce too low/)) {\n        logger.throwError(\"nonce has already been used\", Logger.errors.NONCE_EXPIRED, {\n            error, method, transaction\n        });\n    }\n    // \"replacement transaction underpriced\"\n    if (message.match(/replacement transaction underpriced/)) {\n        logger.throwError(\"replacement fee too low\", Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error, method, transaction\n        });\n    }\n    // \"replacement transaction underpriced\"\n    if (message.match(/only replay-protected/)) {\n        logger.throwError(\"legacy pre-eip-155 transactions not supported\", Logger.errors.UNSUPPORTED_OPERATION, {\n            error, method, transaction\n        });\n    }\n    if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted/)) {\n        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error, method, transaction\n        });\n    }\n    throw error;\n}\nfunction timer(timeout) {\n    return new Promise(function (resolve) {\n        setTimeout(resolve, timeout);\n    });\n}\nfunction getResult(payload) {\n    if (payload.error) {\n        // @TODO: not any\n        const error = new Error(payload.error.message);\n        error.code = payload.error.code;\n        error.data = payload.error.data;\n        throw error;\n    }\n    return payload.result;\n}\nfunction getLowerCase(value) {\n    if (value) {\n        return value.toLowerCase();\n    }\n    return value;\n}\nconst _constructorGuard = {};\nexport class JsonRpcSigner extends Signer {\n    constructor(constructorGuard, provider, addressOrIndex) {\n        logger.checkNew(new.target, JsonRpcSigner);\n        super();\n        if (constructorGuard !== _constructorGuard) {\n            throw new Error(\"do not call the JsonRpcSigner constructor directly; use provider.getSigner\");\n        }\n        defineReadOnly(this, \"provider\", provider);\n        if (addressOrIndex == null) {\n            addressOrIndex = 0;\n        }\n        if (typeof (addressOrIndex) === \"string\") {\n            defineReadOnly(this, \"_address\", this.provider.formatter.address(addressOrIndex));\n            defineReadOnly(this, \"_index\", null);\n        }\n        else if (typeof (addressOrIndex) === \"number\") {\n            defineReadOnly(this, \"_index\", addressOrIndex);\n            defineReadOnly(this, \"_address\", null);\n        }\n        else {\n            logger.throwArgumentError(\"invalid address or index\", \"addressOrIndex\", addressOrIndex);\n        }\n    }\n    connect(provider) {\n        return logger.throwError(\"cannot alter JSON-RPC Signer connection\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"connect\"\n        });\n    }\n    connectUnchecked() {\n        return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);\n    }\n    getAddress() {\n        if (this._address) {\n            return Promise.resolve(this._address);\n        }\n        return this.provider.send(\"eth_accounts\", []).then((accounts) => {\n            if (accounts.length <= this._index) {\n                logger.throwError(\"unknown account #\" + this._index, Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"getAddress\"\n                });\n            }\n            return this.provider.formatter.address(accounts[this._index]);\n        });\n    }\n    sendUncheckedTransaction(transaction) {\n        transaction = shallowCopy(transaction);\n        const fromAddress = this.getAddress().then((address) => {\n            if (address) {\n                address = address.toLowerCase();\n            }\n            return address;\n        });\n        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n        // wishes to use this, it is easy to specify explicitly, otherwise\n        // we look it up for them.\n        if (transaction.gasLimit == null) {\n            const estimate = shallowCopy(transaction);\n            estimate.from = fromAddress;\n            transaction.gasLimit = this.provider.estimateGas(estimate);\n        }\n        if (transaction.to != null) {\n            transaction.to = Promise.resolve(transaction.to).then((to) => __awaiter(this, void 0, void 0, function* () {\n                if (to == null) {\n                    return null;\n                }\n                const address = yield this.provider.resolveName(to);\n                if (address == null) {\n                    logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                }\n                return address;\n            }));\n        }\n        return resolveProperties({\n            tx: resolveProperties(transaction),\n            sender: fromAddress\n        }).then(({ tx, sender }) => {\n            if (tx.from != null) {\n                if (tx.from.toLowerCase() !== sender) {\n                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n            }\n            else {\n                tx.from = sender;\n            }\n            const hexTx = this.provider.constructor.hexlifyTransaction(tx, { from: true });\n            return this.provider.send(\"eth_sendTransaction\", [hexTx]).then((hash) => {\n                return hash;\n            }, (error) => {\n                return checkError(\"sendTransaction\", error, hexTx);\n            });\n        });\n    }\n    signTransaction(transaction) {\n        return logger.throwError(\"signing transactions is unsupported\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"signTransaction\"\n        });\n    }\n    sendTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // This cannot be mined any earlier than any recent block\n            const blockNumber = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);\n            // Send the transaction\n            const hash = yield this.sendUncheckedTransaction(transaction);\n            try {\n                // Unfortunately, JSON-RPC only provides and opaque transaction hash\n                // for a response, and we need the actual transaction, so we poll\n                // for it; it should show up very quickly\n                return yield poll(() => __awaiter(this, void 0, void 0, function* () {\n                    const tx = yield this.provider.getTransaction(hash);\n                    if (tx === null) {\n                        return undefined;\n                    }\n                    return this.provider._wrapTransaction(tx, hash, blockNumber);\n                }), { oncePoll: this.provider });\n            }\n            catch (error) {\n                error.transactionHash = hash;\n                throw error;\n            }\n        });\n    }\n    signMessage(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = ((typeof (message) === \"string\") ? toUtf8Bytes(message) : message);\n            const address = yield this.getAddress();\n            // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n            return yield this.provider.send(\"eth_sign\", [address.toLowerCase(), hexlify(data)]);\n        });\n    }\n    _signTypedData(domain, types, value) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Populate any ENS names (in-place)\n            const populated = yield _TypedDataEncoder.resolveNames(domain, types, value, (name) => {\n                return this.provider.resolveName(name);\n            });\n            const address = yield this.getAddress();\n            return yield this.provider.send(\"eth_signTypedData_v4\", [\n                address.toLowerCase(),\n                JSON.stringify(_TypedDataEncoder.getPayload(populated.domain, types, populated.value))\n            ]);\n        });\n    }\n    unlock(password) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const provider = this.provider;\n            const address = yield this.getAddress();\n            return provider.send(\"personal_unlockAccount\", [address.toLowerCase(), password, null]);\n        });\n    }\n}\nclass UncheckedJsonRpcSigner extends JsonRpcSigner {\n    sendTransaction(transaction) {\n        return this.sendUncheckedTransaction(transaction).then((hash) => {\n            return {\n                hash: hash,\n                nonce: null,\n                gasLimit: null,\n                gasPrice: null,\n                data: null,\n                value: null,\n                chainId: null,\n                confirmations: 0,\n                from: null,\n                wait: (confirmations) => { return this.provider.waitForTransaction(hash, confirmations); }\n            };\n        });\n    }\n}\nconst allowedTransactionKeys = {\n    chainId: true, data: true, gasLimit: true, gasPrice: true, nonce: true, to: true, value: true,\n    type: true, accessList: true,\n    maxFeePerGas: true, maxPriorityFeePerGas: true\n};\nexport class JsonRpcProvider extends BaseProvider {\n    constructor(url, network) {\n        logger.checkNew(new.target, JsonRpcProvider);\n        let networkOrReady = network;\n        // The network is unknown, query the JSON-RPC for it\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    this.detectNetwork().then((network) => {\n                        resolve(network);\n                    }, (error) => {\n                        reject(error);\n                    });\n                }, 0);\n            });\n        }\n        super(networkOrReady);\n        // Default URL\n        if (!url) {\n            url = getStatic(this.constructor, \"defaultUrl\")();\n        }\n        if (typeof (url) === \"string\") {\n            defineReadOnly(this, \"connection\", Object.freeze({\n                url: url\n            }));\n        }\n        else {\n            defineReadOnly(this, \"connection\", Object.freeze(shallowCopy(url)));\n        }\n        this._nextId = 42;\n    }\n    get _cache() {\n        if (this._eventLoopCache == null) {\n            this._eventLoopCache = {};\n        }\n        return this._eventLoopCache;\n    }\n    static defaultUrl() {\n        return \"http:/\\/localhost:8545\";\n    }\n    detectNetwork() {\n        if (!this._cache[\"detectNetwork\"]) {\n            this._cache[\"detectNetwork\"] = this._uncachedDetectNetwork();\n            // Clear this cache at the beginning of the next event loop\n            setTimeout(() => {\n                this._cache[\"detectNetwork\"] = null;\n            }, 0);\n        }\n        return this._cache[\"detectNetwork\"];\n    }\n    _uncachedDetectNetwork() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield timer(0);\n            let chainId = null;\n            try {\n                chainId = yield this.send(\"eth_chainId\", []);\n            }\n            catch (error) {\n                try {\n                    chainId = yield this.send(\"net_version\", []);\n                }\n                catch (error) { }\n            }\n            if (chainId != null) {\n                const getNetwork = getStatic(this.constructor, \"getNetwork\");\n                try {\n                    return getNetwork(BigNumber.from(chainId).toNumber());\n                }\n                catch (error) {\n                    return logger.throwError(\"could not detect network\", Logger.errors.NETWORK_ERROR, {\n                        chainId: chainId,\n                        event: \"invalidNetwork\",\n                        serverError: error\n                    });\n                }\n            }\n            return logger.throwError(\"could not detect network\", Logger.errors.NETWORK_ERROR, {\n                event: \"noNetwork\"\n            });\n        });\n    }\n    getSigner(addressOrIndex) {\n        return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);\n    }\n    getUncheckedSigner(addressOrIndex) {\n        return this.getSigner(addressOrIndex).connectUnchecked();\n    }\n    listAccounts() {\n        return this.send(\"eth_accounts\", []).then((accounts) => {\n            return accounts.map((a) => this.formatter.address(a));\n        });\n    }\n    send(method, params) {\n        const request = {\n            method: method,\n            params: params,\n            id: (this._nextId++),\n            jsonrpc: \"2.0\"\n        };\n        this.emit(\"debug\", {\n            action: \"request\",\n            request: deepCopy(request),\n            provider: this\n        });\n        // We can expand this in the future to any call, but for now these\n        // are the biggest wins and do not require any serializing parameters.\n        const cache = ([\"eth_chainId\", \"eth_blockNumber\"].indexOf(method) >= 0);\n        if (cache && this._cache[method]) {\n            return this._cache[method];\n        }\n        const result = fetchJson(this.connection, JSON.stringify(request), getResult).then((result) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                request: request,\n                response: result,\n                provider: this\n            });\n            return result;\n        }, (error) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                error: error,\n                request: request,\n                provider: this\n            });\n            throw error;\n        });\n        // Cache the fetch, but clear it on the next event loop\n        if (cache) {\n            this._cache[method] = result;\n            setTimeout(() => {\n                this._cache[method] = null;\n            }, 0);\n        }\n        return result;\n    }\n    prepareRequest(method, params) {\n        switch (method) {\n            case \"getBlockNumber\":\n                return [\"eth_blockNumber\", []];\n            case \"getGasPrice\":\n                return [\"eth_gasPrice\", []];\n            case \"getBalance\":\n                return [\"eth_getBalance\", [getLowerCase(params.address), params.blockTag]];\n            case \"getTransactionCount\":\n                return [\"eth_getTransactionCount\", [getLowerCase(params.address), params.blockTag]];\n            case \"getCode\":\n                return [\"eth_getCode\", [getLowerCase(params.address), params.blockTag]];\n            case \"getStorageAt\":\n                return [\"eth_getStorageAt\", [getLowerCase(params.address), params.position, params.blockTag]];\n            case \"sendTransaction\":\n                return [\"eth_sendRawTransaction\", [params.signedTransaction]];\n            case \"getBlock\":\n                if (params.blockTag) {\n                    return [\"eth_getBlockByNumber\", [params.blockTag, !!params.includeTransactions]];\n                }\n                else if (params.blockHash) {\n                    return [\"eth_getBlockByHash\", [params.blockHash, !!params.includeTransactions]];\n                }\n                return null;\n            case \"getTransaction\":\n                return [\"eth_getTransactionByHash\", [params.transactionHash]];\n            case \"getTransactionReceipt\":\n                return [\"eth_getTransactionReceipt\", [params.transactionHash]];\n            case \"call\": {\n                const hexlifyTransaction = getStatic(this.constructor, \"hexlifyTransaction\");\n                return [\"eth_call\", [hexlifyTransaction(params.transaction, { from: true }), params.blockTag]];\n            }\n            case \"estimateGas\": {\n                const hexlifyTransaction = getStatic(this.constructor, \"hexlifyTransaction\");\n                return [\"eth_estimateGas\", [hexlifyTransaction(params.transaction, { from: true })]];\n            }\n            case \"getLogs\":\n                if (params.filter && params.filter.address != null) {\n                    params.filter.address = getLowerCase(params.filter.address);\n                }\n                return [\"eth_getLogs\", [params.filter]];\n            default:\n                break;\n        }\n        return null;\n    }\n    perform(method, params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Legacy networks do not like the type field being passed along (which\n            // is fair), so we delete type if it is 0 and a non-EIP-1559 network\n            if (method === \"call\" || method === \"estimateGas\") {\n                const tx = params.transaction;\n                if (tx && tx.type != null && BigNumber.from(tx.type).isZero()) {\n                    // If there are no EIP-1559 properties, it might be non-EIP-a559\n                    if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {\n                        const feeData = yield this.getFeeData();\n                        if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\n                            // Network doesn't know about EIP-1559 (and hence type)\n                            params = shallowCopy(params);\n                            params.transaction = shallowCopy(tx);\n                            delete params.transaction.type;\n                        }\n                    }\n                }\n            }\n            const args = this.prepareRequest(method, params);\n            if (args == null) {\n                logger.throwError(method + \" not implemented\", Logger.errors.NOT_IMPLEMENTED, { operation: method });\n            }\n            try {\n                return yield this.send(args[0], args[1]);\n            }\n            catch (error) {\n                return checkError(method, error, params);\n            }\n        });\n    }\n    _startEvent(event) {\n        if (event.tag === \"pending\") {\n            this._startPending();\n        }\n        super._startEvent(event);\n    }\n    _startPending() {\n        if (this._pendingFilter != null) {\n            return;\n        }\n        const self = this;\n        const pendingFilter = this.send(\"eth_newPendingTransactionFilter\", []);\n        this._pendingFilter = pendingFilter;\n        pendingFilter.then(function (filterId) {\n            function poll() {\n                self.send(\"eth_getFilterChanges\", [filterId]).then(function (hashes) {\n                    if (self._pendingFilter != pendingFilter) {\n                        return null;\n                    }\n                    let seq = Promise.resolve();\n                    hashes.forEach(function (hash) {\n                        // @TODO: This should be garbage collected at some point... How? When?\n                        self._emitted[\"t:\" + hash.toLowerCase()] = \"pending\";\n                        seq = seq.then(function () {\n                            return self.getTransaction(hash).then(function (tx) {\n                                self.emit(\"pending\", tx);\n                                return null;\n                            });\n                        });\n                    });\n                    return seq.then(function () {\n                        return timer(1000);\n                    });\n                }).then(function () {\n                    if (self._pendingFilter != pendingFilter) {\n                        self.send(\"eth_uninstallFilter\", [filterId]);\n                        return;\n                    }\n                    setTimeout(function () { poll(); }, 0);\n                    return null;\n                }).catch((error) => { });\n            }\n            poll();\n            return filterId;\n        }).catch((error) => { });\n    }\n    _stopEvent(event) {\n        if (event.tag === \"pending\" && this.listenerCount(\"pending\") === 0) {\n            this._pendingFilter = null;\n        }\n        super._stopEvent(event);\n    }\n    // Convert an ethers.js transaction into a JSON-RPC transaction\n    //  - gasLimit => gas\n    //  - All values hexlified\n    //  - All numeric values zero-striped\n    //  - All addresses are lowercased\n    // NOTE: This allows a TransactionRequest, but all values should be resolved\n    //       before this is called\n    // @TODO: This will likely be removed in future versions and prepareRequest\n    //        will be the preferred method for this.\n    static hexlifyTransaction(transaction, allowExtra) {\n        // Check only allowed properties are given\n        const allowed = shallowCopy(allowedTransactionKeys);\n        if (allowExtra) {\n            for (const key in allowExtra) {\n                if (allowExtra[key]) {\n                    allowed[key] = true;\n                }\n            }\n        }\n        checkProperties(transaction, allowed);\n        const result = {};\n        // Some nodes (INFURA ropsten; INFURA mainnet is fine) do not like leading zeros.\n        [\"gasLimit\", \"gasPrice\", \"type\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"value\"].forEach(function (key) {\n            if (transaction[key] == null) {\n                return;\n            }\n            const value = hexValue(transaction[key]);\n            if (key === \"gasLimit\") {\n                key = \"gas\";\n            }\n            result[key] = value;\n        });\n        [\"from\", \"to\", \"data\"].forEach(function (key) {\n            if (transaction[key] == null) {\n                return;\n            }\n            result[key] = hexlify(transaction[key]);\n        });\n        if (transaction.accessList) {\n            result[\"accessList\"] = accessListify(transaction.accessList);\n        }\n        return result;\n    }\n}\n//# sourceMappingURL=json-rpc-provider.js.map","\"use strict\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nlet WS = null;\ntry {\n    WS = WebSocket;\n    if (WS == null) {\n        throw new Error(\"inject please\");\n    }\n}\ncatch (error) {\n    const logger = new Logger(version);\n    WS = function () {\n        logger.throwError(\"WebSockets not supported in this environment\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"new WebSocket()\"\n        });\n    };\n}\n//export default WS;\n//module.exports = WS;\nexport { WS as WebSocket };\n//# sourceMappingURL=ws.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\nimport { WebSocket } from \"./ws\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n/**\n *  Notes:\n *\n *  This provider differs a bit from the polling providers. One main\n *  difference is how it handles consistency. The polling providers\n *  will stall responses to ensure a consistent state, while this\n *  WebSocket provider assumes the connected backend will manage this.\n *\n *  For example, if a polling provider emits an event which indicats\n *  the event occurred in blockhash XXX, a call to fetch that block by\n *  its hash XXX, if not present will retry until it is present. This\n *  can occur when querying a pool of nodes that are mildly out of sync\n *  with each other.\n */\nlet NextId = 1;\n// For more info about the Real-time Event API see:\n//   https://geth.ethereum.org/docs/rpc/pubsub\nexport class WebSocketProvider extends JsonRpcProvider {\n    constructor(url, network) {\n        // This will be added in the future; please open an issue to expedite\n        if (network === \"any\") {\n            logger.throwError(\"WebSocketProvider does not support 'any' network yet\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"network:any\"\n            });\n        }\n        super(url, network);\n        this._pollingInterval = -1;\n        this._wsReady = false;\n        defineReadOnly(this, \"_websocket\", new WebSocket(this.connection.url));\n        defineReadOnly(this, \"_requests\", {});\n        defineReadOnly(this, \"_subs\", {});\n        defineReadOnly(this, \"_subIds\", {});\n        defineReadOnly(this, \"_detectNetwork\", super.detectNetwork());\n        // Stall sending requests until the socket is open...\n        this._websocket.onopen = () => {\n            this._wsReady = true;\n            Object.keys(this._requests).forEach((id) => {\n                this._websocket.send(this._requests[id].payload);\n            });\n        };\n        this._websocket.onmessage = (messageEvent) => {\n            const data = messageEvent.data;\n            const result = JSON.parse(data);\n            if (result.id != null) {\n                const id = String(result.id);\n                const request = this._requests[id];\n                delete this._requests[id];\n                if (result.result !== undefined) {\n                    request.callback(null, result.result);\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        request: JSON.parse(request.payload),\n                        response: result.result,\n                        provider: this\n                    });\n                }\n                else {\n                    let error = null;\n                    if (result.error) {\n                        error = new Error(result.error.message || \"unknown error\");\n                        defineReadOnly(error, \"code\", result.error.code || null);\n                        defineReadOnly(error, \"response\", data);\n                    }\n                    else {\n                        error = new Error(\"unknown error\");\n                    }\n                    request.callback(error, undefined);\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: JSON.parse(request.payload),\n                        provider: this\n                    });\n                }\n            }\n            else if (result.method === \"eth_subscription\") {\n                // Subscription...\n                const sub = this._subs[result.params.subscription];\n                if (sub) {\n                    //this.emit.apply(this,                  );\n                    sub.processFunc(result.params.result);\n                }\n            }\n            else {\n                console.warn(\"this should not happen\");\n            }\n        };\n        // This Provider does not actually poll, but we want to trigger\n        // poll events for things that depend on them (like stalling for\n        // block and transaction lookups)\n        const fauxPoll = setInterval(() => {\n            this.emit(\"poll\");\n        }, 1000);\n        if (fauxPoll.unref) {\n            fauxPoll.unref();\n        }\n    }\n    detectNetwork() {\n        return this._detectNetwork;\n    }\n    get pollingInterval() {\n        return 0;\n    }\n    resetEventsBlock(blockNumber) {\n        logger.throwError(\"cannot reset events block on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"resetEventBlock\"\n        });\n    }\n    set pollingInterval(value) {\n        logger.throwError(\"cannot set polling interval on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPollingInterval\"\n        });\n    }\n    poll() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return null;\n        });\n    }\n    set polling(value) {\n        if (!value) {\n            return;\n        }\n        logger.throwError(\"cannot set polling on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPolling\"\n        });\n    }\n    send(method, params) {\n        const rid = NextId++;\n        return new Promise((resolve, reject) => {\n            function callback(error, result) {\n                if (error) {\n                    return reject(error);\n                }\n                return resolve(result);\n            }\n            const payload = JSON.stringify({\n                method: method,\n                params: params,\n                id: rid,\n                jsonrpc: \"2.0\"\n            });\n            this.emit(\"debug\", {\n                action: \"request\",\n                request: JSON.parse(payload),\n                provider: this\n            });\n            this._requests[String(rid)] = { callback, payload };\n            if (this._wsReady) {\n                this._websocket.send(payload);\n            }\n        });\n    }\n    static defaultUrl() {\n        return \"ws:/\\/localhost:8546\";\n    }\n    _subscribe(tag, param, processFunc) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let subIdPromise = this._subIds[tag];\n            if (subIdPromise == null) {\n                subIdPromise = Promise.all(param).then((param) => {\n                    return this.send(\"eth_subscribe\", param);\n                });\n                this._subIds[tag] = subIdPromise;\n            }\n            const subId = yield subIdPromise;\n            this._subs[subId] = { tag, processFunc };\n        });\n    }\n    _startEvent(event) {\n        switch (event.type) {\n            case \"block\":\n                this._subscribe(\"block\", [\"newHeads\"], (result) => {\n                    const blockNumber = BigNumber.from(result.number).toNumber();\n                    this._emitted.block = blockNumber;\n                    this.emit(\"block\", blockNumber);\n                });\n                break;\n            case \"pending\":\n                this._subscribe(\"pending\", [\"newPendingTransactions\"], (result) => {\n                    this.emit(\"pending\", result);\n                });\n                break;\n            case \"filter\":\n                this._subscribe(event.tag, [\"logs\", this._getFilter(event.filter)], (result) => {\n                    if (result.removed == null) {\n                        result.removed = false;\n                    }\n                    this.emit(event.filter, this.formatter.filterLog(result));\n                });\n                break;\n            case \"tx\": {\n                const emitReceipt = (event) => {\n                    const hash = event.hash;\n                    this.getTransactionReceipt(hash).then((receipt) => {\n                        if (!receipt) {\n                            return;\n                        }\n                        this.emit(hash, receipt);\n                    });\n                };\n                // In case it is already mined\n                emitReceipt(event);\n                // To keep things simple, we start up a single newHeads subscription\n                // to keep an eye out for transactions we are watching for.\n                // Starting a subscription for an event (i.e. \"tx\") that is already\n                // running is (basically) a nop.\n                this._subscribe(\"tx\", [\"newHeads\"], (result) => {\n                    this._events.filter((e) => (e.type === \"tx\")).forEach(emitReceipt);\n                });\n                break;\n            }\n            // Nothing is needed\n            case \"debug\":\n            case \"poll\":\n            case \"willPoll\":\n            case \"didPoll\":\n            case \"error\":\n                break;\n            default:\n                console.log(\"unhandled:\", event);\n                break;\n        }\n    }\n    _stopEvent(event) {\n        let tag = event.tag;\n        if (event.type === \"tx\") {\n            // There are remaining transaction event listeners\n            if (this._events.filter((e) => (e.type === \"tx\")).length) {\n                return;\n            }\n            tag = \"tx\";\n        }\n        else if (this.listenerCount(event.event)) {\n            // There are remaining event listeners\n            return;\n        }\n        const subId = this._subIds[tag];\n        if (!subId) {\n            return;\n        }\n        delete this._subIds[tag];\n        subId.then((subId) => {\n            if (!this._subs[subId]) {\n                return;\n            }\n            delete this._subs[subId];\n            this.send(\"eth_unsubscribe\", [subId]);\n        });\n    }\n    destroy() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Wait until we have connected before trying to disconnect\n            if (this._websocket.readyState === WebSocket.CONNECTING) {\n                yield (new Promise((resolve) => {\n                    this._websocket.onopen = function () {\n                        resolve(true);\n                    };\n                    this._websocket.onerror = function () {\n                        resolve(false);\n                    };\n                }));\n            }\n            // Hangup\n            // See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n            this._websocket.close(1000);\n        });\n    }\n}\n//# sourceMappingURL=websocket-provider.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { defineReadOnly, getStatic } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\n// A StaticJsonRpcProvider is useful when you *know* for certain that\n// the backend will never change, as it never calls eth_chainId to\n// verify its backend. However, if the backend does change, the effects\n// are undefined and may include:\n// - inconsistent results\n// - locking up the UI\n// - block skew warnings\n// - wrong results\n// If the network is not explicit (i.e. auto-detection is expected), the\n// node MUST be running and available to respond to requests BEFORE this\n// is instantiated.\nexport class StaticJsonRpcProvider extends JsonRpcProvider {\n    detectNetwork() {\n        const _super = Object.create(null, {\n            detectNetwork: { get: () => super.detectNetwork }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            let network = this.network;\n            if (network == null) {\n                network = yield _super.detectNetwork.call(this);\n                if (!network) {\n                    logger.throwError(\"no network detected\", Logger.errors.UNKNOWN_ERROR, {});\n                }\n                // If still not set, set it\n                if (this._network == null) {\n                    // A static network does not support \"any\"\n                    defineReadOnly(this, \"_network\", network);\n                    this.emit(\"network\", network, null);\n                }\n            }\n            return network;\n        });\n    }\n}\nexport class UrlJsonRpcProvider extends StaticJsonRpcProvider {\n    constructor(network, apiKey) {\n        logger.checkAbstract(new.target, UrlJsonRpcProvider);\n        // Normalize the Network and API Key\n        network = getStatic((new.target), \"getNetwork\")(network);\n        apiKey = getStatic((new.target), \"getApiKey\")(apiKey);\n        const connection = getStatic((new.target), \"getUrl\")(network, apiKey);\n        super(connection, network);\n        if (typeof (apiKey) === \"string\") {\n            defineReadOnly(this, \"apiKey\", apiKey);\n        }\n        else if (apiKey != null) {\n            Object.keys(apiKey).forEach((key) => {\n                defineReadOnly(this, key, apiKey[key]);\n            });\n        }\n    }\n    _startPending() {\n        logger.warn(\"WARNING: API provider does not support pending filters\");\n    }\n    isCommunityResource() {\n        return false;\n    }\n    getSigner(address) {\n        return logger.throwError(\"API provider does not support signing\", Logger.errors.UNSUPPORTED_OPERATION, { operation: \"getSigner\" });\n    }\n    listAccounts() {\n        return Promise.resolve([]);\n    }\n    // Return a defaultApiKey if null, otherwise validate the API key\n    static getApiKey(apiKey) {\n        return apiKey;\n    }\n    // Returns the url or connection for the given network and API key. The\n    // API key will have been sanitized by the getApiKey first, so any validation\n    // or transformations can be done there.\n    static getUrl(network, apiKey) {\n        return logger.throwError(\"not implemented; sub-classes must override getUrl\", Logger.errors.NOT_IMPLEMENTED, {\n            operation: \"getUrl\"\n        });\n    }\n}\n//# sourceMappingURL=url-json-rpc-provider.js.map","\"use strict\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { showThrottleMessage } from \"./formatter\";\nimport { WebSocketProvider } from \"./websocket-provider\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n// This key was provided to ethers.js by Alchemy to be used by the\n// default provider, but it is recommended that for your own\n// production environments, that you acquire your own API key at:\n//   https://dashboard.alchemyapi.io\nconst defaultApiKey = \"_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC\";\nexport class AlchemyWebSocketProvider extends WebSocketProvider {\n    constructor(network, apiKey) {\n        const provider = new AlchemyProvider(network, apiKey);\n        const url = provider.connection.url.replace(/^http/i, \"ws\")\n            .replace(\".alchemyapi.\", \".ws.alchemyapi.\");\n        super(url, provider.network);\n        defineReadOnly(this, \"apiKey\", provider.apiKey);\n    }\n    isCommunityResource() {\n        return (this.apiKey === defaultApiKey);\n    }\n}\nexport class AlchemyProvider extends UrlJsonRpcProvider {\n    static getWebSocketProvider(network, apiKey) {\n        return new AlchemyWebSocketProvider(network, apiKey);\n    }\n    static getApiKey(apiKey) {\n        if (apiKey == null) {\n            return defaultApiKey;\n        }\n        if (apiKey && typeof (apiKey) !== \"string\") {\n            logger.throwArgumentError(\"invalid apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKey;\n    }\n    static getUrl(network, apiKey) {\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"eth-mainnet.alchemyapi.io/v2/\";\n                break;\n            case \"ropsten\":\n                host = \"eth-ropsten.alchemyapi.io/v2/\";\n                break;\n            case \"rinkeby\":\n                host = \"eth-rinkeby.alchemyapi.io/v2/\";\n                break;\n            case \"goerli\":\n                host = \"eth-goerli.alchemyapi.io/v2/\";\n                break;\n            case \"kovan\":\n                host = \"eth-kovan.alchemyapi.io/v2/\";\n                break;\n            case \"matic\":\n                host = \"polygon-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"maticmum\":\n                host = \"polygon-mumbai.g.alchemy.com/v2/\";\n                break;\n            default:\n                logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n        return {\n            allowGzip: true,\n            url: (\"https:/\" + \"/\" + host + apiKey),\n            throttleCallback: (attempt, url) => {\n                if (apiKey === defaultApiKey) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n    }\n    isCommunityResource() {\n        return (this.apiKey === defaultApiKey);\n    }\n}\n//# sourceMappingURL=alchemy-provider.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nexport class CloudflareProvider extends UrlJsonRpcProvider {\n    static getApiKey(apiKey) {\n        if (apiKey != null) {\n            logger.throwArgumentError(\"apiKey not supported for cloudflare\", \"apiKey\", apiKey);\n        }\n        return null;\n    }\n    static getUrl(network, apiKey) {\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"https://cloudflare-eth.com/\";\n                break;\n            default:\n                logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n        return host;\n    }\n    perform(method, params) {\n        const _super = Object.create(null, {\n            perform: { get: () => super.perform }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            // The Cloudflare provider does not support eth_blockNumber,\n            // so we get the latest block and pull it from that\n            if (method === \"getBlockNumber\") {\n                const block = yield _super.perform.call(this, \"getBlock\", { blockTag: \"latest\" });\n                return block.number;\n            }\n            return _super.perform.call(this, method, params);\n        });\n    }\n}\n//# sourceMappingURL=cloudflare-provider.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { hexlify, hexValue, isHexString } from \"@ethersproject/bytes\";\nimport { deepCopy, defineReadOnly } from \"@ethersproject/properties\";\nimport { accessListify } from \"@ethersproject/transactions\";\nimport { fetchJson } from \"@ethersproject/web\";\nimport { showThrottleMessage } from \"./formatter\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { BaseProvider } from \"./base-provider\";\n// The transaction has already been sanitized by the calls in Provider\nfunction getTransactionPostData(transaction) {\n    const result = {};\n    for (let key in transaction) {\n        if (transaction[key] == null) {\n            continue;\n        }\n        let value = transaction[key];\n        if (key === \"type\" && value === 0) {\n            continue;\n        }\n        // Quantity-types require no leading zero, unless 0\n        if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key]) {\n            value = hexValue(hexlify(value));\n        }\n        else if (key === \"accessList\") {\n            value = \"[\" + accessListify(value).map((set) => {\n                return `{address:\"${set.address}\",storageKeys:[\"${set.storageKeys.join('\",\"')}\"]}`;\n            }).join(\",\") + \"]\";\n        }\n        else {\n            value = hexlify(value);\n        }\n        result[key] = value;\n    }\n    return result;\n}\nfunction getResult(result) {\n    // getLogs, getHistory have weird success responses\n    if (result.status == 0 && (result.message === \"No records found\" || result.message === \"No transactions found\")) {\n        return result.result;\n    }\n    if (result.status != 1 || result.message != \"OK\") {\n        const error = new Error(\"invalid response\");\n        error.result = JSON.stringify(result);\n        if ((result.result || \"\").toLowerCase().indexOf(\"rate limit\") >= 0) {\n            error.throttleRetry = true;\n        }\n        throw error;\n    }\n    return result.result;\n}\nfunction getJsonResult(result) {\n    // This response indicates we are being throttled\n    if (result && result.status == 0 && result.message == \"NOTOK\" && (result.result || \"\").toLowerCase().indexOf(\"rate limit\") >= 0) {\n        const error = new Error(\"throttled response\");\n        error.result = JSON.stringify(result);\n        error.throttleRetry = true;\n        throw error;\n    }\n    if (result.jsonrpc != \"2.0\") {\n        // @TODO: not any\n        const error = new Error(\"invalid response\");\n        error.result = JSON.stringify(result);\n        throw error;\n    }\n    if (result.error) {\n        // @TODO: not any\n        const error = new Error(result.error.message || \"unknown error\");\n        if (result.error.code) {\n            error.code = result.error.code;\n        }\n        if (result.error.data) {\n            error.data = result.error.data;\n        }\n        throw error;\n    }\n    return result.result;\n}\n// The blockTag was normalized as a string by the Provider pre-perform operations\nfunction checkLogTag(blockTag) {\n    if (blockTag === \"pending\") {\n        throw new Error(\"pending not supported\");\n    }\n    if (blockTag === \"latest\") {\n        return blockTag;\n    }\n    return parseInt(blockTag.substring(2), 16);\n}\nconst defaultApiKey = \"9D13ZE7XSBTJ94N9BNJ2MA33VMAY2YPIRB\";\nfunction checkError(method, error, transaction) {\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\" && error.code === Logger.errors.SERVER_ERROR) {\n        const e = error.error;\n        // Etherscan keeps changing their string\n        if (e && (e.message.match(/reverted/i) || e.message.match(/VM execution error/i))) {\n            // Etherscan prefixes the data like \"Reverted 0x1234\"\n            let data = e.data;\n            if (data) {\n                data = \"0x\" + data.replace(/^.*0x/i, \"\");\n            }\n            if (isHexString(data)) {\n                return data;\n            }\n            logger.throwError(\"missing revert data in call exception\", Logger.errors.CALL_EXCEPTION, {\n                error, data: \"0x\"\n            });\n        }\n    }\n    // Get the message from any nested error structure\n    let message = error.message;\n    if (error.code === Logger.errors.SERVER_ERROR) {\n        if (error.error && typeof (error.error.message) === \"string\") {\n            message = error.error.message;\n        }\n        else if (typeof (error.body) === \"string\") {\n            message = error.body;\n        }\n        else if (typeof (error.responseText) === \"string\") {\n            message = error.responseText;\n        }\n    }\n    message = (message || \"\").toLowerCase();\n    // \"Insufficient funds. The account you tried to send transaction from does not have enough funds. Required 21464000000000 and got: 0\"\n    if (message.match(/insufficient funds/)) {\n        logger.throwError(\"insufficient funds for intrinsic transaction cost\", Logger.errors.INSUFFICIENT_FUNDS, {\n            error, method, transaction\n        });\n    }\n    // \"Transaction with the same hash was already imported.\"\n    if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {\n        logger.throwError(\"nonce has already been used\", Logger.errors.NONCE_EXPIRED, {\n            error, method, transaction\n        });\n    }\n    // \"Transaction gas price is too low. There is another transaction with same nonce in the queue. Try increasing the gas price or incrementing the nonce.\"\n    if (message.match(/another transaction with same nonce/)) {\n        logger.throwError(\"replacement fee too low\", Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error, method, transaction\n        });\n    }\n    if (message.match(/execution failed due to an exception|execution reverted/)) {\n        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error, method, transaction\n        });\n    }\n    throw error;\n}\nexport class EtherscanProvider extends BaseProvider {\n    constructor(network, apiKey) {\n        logger.checkNew(new.target, EtherscanProvider);\n        super(network);\n        defineReadOnly(this, \"baseUrl\", this.getBaseUrl());\n        defineReadOnly(this, \"apiKey\", apiKey || defaultApiKey);\n    }\n    getBaseUrl() {\n        switch (this.network ? this.network.name : \"invalid\") {\n            case \"homestead\":\n                return \"https:/\\/api.etherscan.io\";\n            case \"ropsten\":\n                return \"https:/\\/api-ropsten.etherscan.io\";\n            case \"rinkeby\":\n                return \"https:/\\/api-rinkeby.etherscan.io\";\n            case \"kovan\":\n                return \"https:/\\/api-kovan.etherscan.io\";\n            case \"goerli\":\n                return \"https:/\\/api-goerli.etherscan.io\";\n            default:\n        }\n        return logger.throwArgumentError(\"unsupported network\", \"network\", name);\n    }\n    getUrl(module, params) {\n        const query = Object.keys(params).reduce((accum, key) => {\n            const value = params[key];\n            if (value != null) {\n                accum += `&${key}=${value}`;\n            }\n            return accum;\n        }, \"\");\n        const apiKey = ((this.apiKey) ? `&apikey=${this.apiKey}` : \"\");\n        return `${this.baseUrl}/api?module=${module}${query}${apiKey}`;\n    }\n    getPostUrl() {\n        return `${this.baseUrl}/api`;\n    }\n    getPostData(module, params) {\n        params.module = module;\n        params.apikey = this.apiKey;\n        return params;\n    }\n    fetch(module, params, post) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const url = (post ? this.getPostUrl() : this.getUrl(module, params));\n            const payload = (post ? this.getPostData(module, params) : null);\n            const procFunc = (module === \"proxy\") ? getJsonResult : getResult;\n            this.emit(\"debug\", {\n                action: \"request\",\n                request: url,\n                provider: this\n            });\n            const connection = {\n                url: url,\n                throttleSlotInterval: 1000,\n                throttleCallback: (attempt, url) => {\n                    if (this.isCommunityResource()) {\n                        showThrottleMessage();\n                    }\n                    return Promise.resolve(true);\n                }\n            };\n            let payloadStr = null;\n            if (payload) {\n                connection.headers = { \"content-type\": \"application/x-www-form-urlencoded; charset=UTF-8\" };\n                payloadStr = Object.keys(payload).map((key) => {\n                    return `${key}=${payload[key]}`;\n                }).join(\"&\");\n            }\n            const result = yield fetchJson(connection, payloadStr, procFunc || getJsonResult);\n            this.emit(\"debug\", {\n                action: \"response\",\n                request: url,\n                response: deepCopy(result),\n                provider: this\n            });\n            return result;\n        });\n    }\n    detectNetwork() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.network;\n        });\n    }\n    perform(method, params) {\n        const _super = Object.create(null, {\n            perform: { get: () => super.perform }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            switch (method) {\n                case \"getBlockNumber\":\n                    return this.fetch(\"proxy\", { action: \"eth_blockNumber\" });\n                case \"getGasPrice\":\n                    return this.fetch(\"proxy\", { action: \"eth_gasPrice\" });\n                case \"getBalance\":\n                    // Returns base-10 result\n                    return this.fetch(\"account\", {\n                        action: \"balance\",\n                        address: params.address,\n                        tag: params.blockTag\n                    });\n                case \"getTransactionCount\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getTransactionCount\",\n                        address: params.address,\n                        tag: params.blockTag\n                    });\n                case \"getCode\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getCode\",\n                        address: params.address,\n                        tag: params.blockTag\n                    });\n                case \"getStorageAt\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getStorageAt\",\n                        address: params.address,\n                        position: params.position,\n                        tag: params.blockTag\n                    });\n                case \"sendTransaction\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_sendRawTransaction\",\n                        hex: params.signedTransaction\n                    }, true).catch((error) => {\n                        return checkError(\"sendTransaction\", error, params.signedTransaction);\n                    });\n                case \"getBlock\":\n                    if (params.blockTag) {\n                        return this.fetch(\"proxy\", {\n                            action: \"eth_getBlockByNumber\",\n                            tag: params.blockTag,\n                            boolean: (params.includeTransactions ? \"true\" : \"false\")\n                        });\n                    }\n                    throw new Error(\"getBlock by blockHash not implemented\");\n                case \"getTransaction\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getTransactionByHash\",\n                        txhash: params.transactionHash\n                    });\n                case \"getTransactionReceipt\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getTransactionReceipt\",\n                        txhash: params.transactionHash\n                    });\n                case \"call\": {\n                    if (params.blockTag !== \"latest\") {\n                        throw new Error(\"EtherscanProvider does not support blockTag for call\");\n                    }\n                    const postData = getTransactionPostData(params.transaction);\n                    postData.module = \"proxy\";\n                    postData.action = \"eth_call\";\n                    try {\n                        return yield this.fetch(\"proxy\", postData, true);\n                    }\n                    catch (error) {\n                        return checkError(\"call\", error, params.transaction);\n                    }\n                }\n                case \"estimateGas\": {\n                    const postData = getTransactionPostData(params.transaction);\n                    postData.module = \"proxy\";\n                    postData.action = \"eth_estimateGas\";\n                    try {\n                        return yield this.fetch(\"proxy\", postData, true);\n                    }\n                    catch (error) {\n                        return checkError(\"estimateGas\", error, params.transaction);\n                    }\n                }\n                case \"getLogs\": {\n                    const args = { action: \"getLogs\" };\n                    if (params.filter.fromBlock) {\n                        args.fromBlock = checkLogTag(params.filter.fromBlock);\n                    }\n                    if (params.filter.toBlock) {\n                        args.toBlock = checkLogTag(params.filter.toBlock);\n                    }\n                    if (params.filter.address) {\n                        args.address = params.filter.address;\n                    }\n                    // @TODO: We can handle slightly more complicated logs using the logs API\n                    if (params.filter.topics && params.filter.topics.length > 0) {\n                        if (params.filter.topics.length > 1) {\n                            logger.throwError(\"unsupported topic count\", Logger.errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });\n                        }\n                        if (params.filter.topics.length === 1) {\n                            const topic0 = params.filter.topics[0];\n                            if (typeof (topic0) !== \"string\" || topic0.length !== 66) {\n                                logger.throwError(\"unsupported topic format\", Logger.errors.UNSUPPORTED_OPERATION, { topic0: topic0 });\n                            }\n                            args.topic0 = topic0;\n                        }\n                    }\n                    const logs = yield this.fetch(\"logs\", args);\n                    // Cache txHash => blockHash\n                    let blocks = {};\n                    // Add any missing blockHash to the logs\n                    for (let i = 0; i < logs.length; i++) {\n                        const log = logs[i];\n                        if (log.blockHash != null) {\n                            continue;\n                        }\n                        if (blocks[log.blockNumber] == null) {\n                            const block = yield this.getBlock(log.blockNumber);\n                            if (block) {\n                                blocks[log.blockNumber] = block.hash;\n                            }\n                        }\n                        log.blockHash = blocks[log.blockNumber];\n                    }\n                    return logs;\n                }\n                case \"getEtherPrice\":\n                    if (this.network.name !== \"homestead\") {\n                        return 0.0;\n                    }\n                    return parseFloat((yield this.fetch(\"stats\", { action: \"ethprice\" })).ethusd);\n                default:\n                    break;\n            }\n            return _super.perform.call(this, method, params);\n        });\n    }\n    // Note: The `page` page parameter only allows pagination within the\n    //       10,000 window abailable without a page and offset parameter\n    //       Error: Result window is too large, PageNo x Offset size must\n    //              be less than or equal to 10000\n    getHistory(addressOrName, startBlock, endBlock) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const params = {\n                action: \"txlist\",\n                address: (yield this.resolveName(addressOrName)),\n                startblock: ((startBlock == null) ? 0 : startBlock),\n                endblock: ((endBlock == null) ? 99999999 : endBlock),\n                sort: \"asc\"\n            };\n            const result = yield this.fetch(\"account\", params);\n            return result.map((tx) => {\n                [\"contractAddress\", \"to\"].forEach(function (key) {\n                    if (tx[key] == \"\") {\n                        delete tx[key];\n                    }\n                });\n                if (tx.creates == null && tx.contractAddress != null) {\n                    tx.creates = tx.contractAddress;\n                }\n                const item = this.formatter.transactionResponse(tx);\n                if (tx.timeStamp) {\n                    item.timestamp = parseInt(tx.timeStamp);\n                }\n                return item;\n            });\n        });\n    }\n    isCommunityResource() {\n        return (this.apiKey === defaultApiKey);\n    }\n}\n//# sourceMappingURL=etherscan-provider.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Provider } from \"@ethersproject/abstract-provider\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { isHexString } from \"@ethersproject/bytes\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\nimport { shuffled } from \"@ethersproject/random\";\nimport { poll } from \"@ethersproject/web\";\nimport { BaseProvider } from \"./base-provider\";\nimport { isCommunityResource } from \"./formatter\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nfunction now() { return (new Date()).getTime(); }\n// Returns to network as long as all agree, or null if any is null.\n// Throws an error if any two networks do not match.\nfunction checkNetworks(networks) {\n    let result = null;\n    for (let i = 0; i < networks.length; i++) {\n        const network = networks[i];\n        // Null! We do not know our network; bail.\n        if (network == null) {\n            return null;\n        }\n        if (result) {\n            // Make sure the network matches the previous networks\n            if (!(result.name === network.name && result.chainId === network.chainId &&\n                ((result.ensAddress === network.ensAddress) || (result.ensAddress == null && network.ensAddress == null)))) {\n                logger.throwArgumentError(\"provider mismatch\", \"networks\", networks);\n            }\n        }\n        else {\n            result = network;\n        }\n    }\n    return result;\n}\nfunction median(values, maxDelta) {\n    values = values.slice().sort();\n    const middle = Math.floor(values.length / 2);\n    // Odd length; take the middle\n    if (values.length % 2) {\n        return values[middle];\n    }\n    // Even length; take the average of the two middle\n    const a = values[middle - 1], b = values[middle];\n    if (maxDelta != null && Math.abs(a - b) > maxDelta) {\n        return null;\n    }\n    return (a + b) / 2;\n}\nfunction serialize(value) {\n    if (value === null) {\n        return \"null\";\n    }\n    else if (typeof (value) === \"number\" || typeof (value) === \"boolean\") {\n        return JSON.stringify(value);\n    }\n    else if (typeof (value) === \"string\") {\n        return value;\n    }\n    else if (BigNumber.isBigNumber(value)) {\n        return value.toString();\n    }\n    else if (Array.isArray(value)) {\n        return JSON.stringify(value.map((i) => serialize(i)));\n    }\n    else if (typeof (value) === \"object\") {\n        const keys = Object.keys(value);\n        keys.sort();\n        return \"{\" + keys.map((key) => {\n            let v = value[key];\n            if (typeof (v) === \"function\") {\n                v = \"[function]\";\n            }\n            else {\n                v = serialize(v);\n            }\n            return JSON.stringify(key) + \":\" + v;\n        }).join(\",\") + \"}\";\n    }\n    throw new Error(\"unknown value type: \" + typeof (value));\n}\n// Next request ID to use for emitting debug info\nlet nextRid = 1;\n;\nfunction stall(duration) {\n    let cancel = null;\n    let timer = null;\n    let promise = (new Promise((resolve) => {\n        cancel = function () {\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n            resolve();\n        };\n        timer = setTimeout(cancel, duration);\n    }));\n    const wait = (func) => {\n        promise = promise.then(func);\n        return promise;\n    };\n    function getPromise() {\n        return promise;\n    }\n    return { cancel, getPromise, wait };\n}\nconst ForwardErrors = [\n    Logger.errors.CALL_EXCEPTION,\n    Logger.errors.INSUFFICIENT_FUNDS,\n    Logger.errors.NONCE_EXPIRED,\n    Logger.errors.REPLACEMENT_UNDERPRICED,\n    Logger.errors.UNPREDICTABLE_GAS_LIMIT\n];\nconst ForwardProperties = [\n    \"address\",\n    \"args\",\n    \"errorArgs\",\n    \"errorSignature\",\n    \"method\",\n    \"transaction\",\n];\n;\nfunction exposeDebugConfig(config, now) {\n    const result = {\n        weight: config.weight\n    };\n    Object.defineProperty(result, \"provider\", { get: () => config.provider });\n    if (config.start) {\n        result.start = config.start;\n    }\n    if (now) {\n        result.duration = (now - config.start);\n    }\n    if (config.done) {\n        if (config.error) {\n            result.error = config.error;\n        }\n        else {\n            result.result = config.result || null;\n        }\n    }\n    return result;\n}\nfunction normalizedTally(normalize, quorum) {\n    return function (configs) {\n        // Count the votes for each result\n        const tally = {};\n        configs.forEach((c) => {\n            const value = normalize(c.result);\n            if (!tally[value]) {\n                tally[value] = { count: 0, result: c.result };\n            }\n            tally[value].count++;\n        });\n        // Check for a quorum on any given result\n        const keys = Object.keys(tally);\n        for (let i = 0; i < keys.length; i++) {\n            const check = tally[keys[i]];\n            if (check.count >= quorum) {\n                return check.result;\n            }\n        }\n        // No quroum\n        return undefined;\n    };\n}\nfunction getProcessFunc(provider, method, params) {\n    let normalize = serialize;\n    switch (method) {\n        case \"getBlockNumber\":\n            // Return the median value, unless there is (median + 1) is also\n            // present, in which case that is probably true and the median\n            // is going to be stale soon. In the event of a malicious node,\n            // the lie will be true soon enough.\n            return function (configs) {\n                const values = configs.map((c) => c.result);\n                // Get the median block number\n                let blockNumber = median(configs.map((c) => c.result), 2);\n                if (blockNumber == null) {\n                    return undefined;\n                }\n                blockNumber = Math.ceil(blockNumber);\n                // If the next block height is present, its prolly safe to use\n                if (values.indexOf(blockNumber + 1) >= 0) {\n                    blockNumber++;\n                }\n                // Don't ever roll back the blockNumber\n                if (blockNumber >= provider._highestBlockNumber) {\n                    provider._highestBlockNumber = blockNumber;\n                }\n                return provider._highestBlockNumber;\n            };\n        case \"getGasPrice\":\n            // Return the middle (round index up) value, similar to median\n            // but do not average even entries and choose the higher.\n            // Malicious actors must compromise 50% of the nodes to lie.\n            return function (configs) {\n                const values = configs.map((c) => c.result);\n                values.sort();\n                return values[Math.floor(values.length / 2)];\n            };\n        case \"getEtherPrice\":\n            // Returns the median price. Malicious actors must compromise at\n            // least 50% of the nodes to lie (in a meaningful way).\n            return function (configs) {\n                return median(configs.map((c) => c.result));\n            };\n        // No additional normalizing required; serialize is enough\n        case \"getBalance\":\n        case \"getTransactionCount\":\n        case \"getCode\":\n        case \"getStorageAt\":\n        case \"call\":\n        case \"estimateGas\":\n        case \"getLogs\":\n            break;\n        // We drop the confirmations from transactions as it is approximate\n        case \"getTransaction\":\n        case \"getTransactionReceipt\":\n            normalize = function (tx) {\n                if (tx == null) {\n                    return null;\n                }\n                tx = shallowCopy(tx);\n                tx.confirmations = -1;\n                return serialize(tx);\n            };\n            break;\n        // We drop the confirmations from transactions as it is approximate\n        case \"getBlock\":\n            // We drop the confirmations from transactions as it is approximate\n            if (params.includeTransactions) {\n                normalize = function (block) {\n                    if (block == null) {\n                        return null;\n                    }\n                    block = shallowCopy(block);\n                    block.transactions = block.transactions.map((tx) => {\n                        tx = shallowCopy(tx);\n                        tx.confirmations = -1;\n                        return tx;\n                    });\n                    return serialize(block);\n                };\n            }\n            else {\n                normalize = function (block) {\n                    if (block == null) {\n                        return null;\n                    }\n                    return serialize(block);\n                };\n            }\n            break;\n        default:\n            throw new Error(\"unknown method: \" + method);\n    }\n    // Return the result if and only if the expected quorum is\n    // satisfied and agreed upon for the final result.\n    return normalizedTally(normalize, provider.quorum);\n}\n// If we are doing a blockTag query, we need to make sure the backend is\n// caught up to the FallbackProvider, before sending a request to it.\nfunction waitForSync(config, blockNumber) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const provider = (config.provider);\n        if ((provider.blockNumber != null && provider.blockNumber >= blockNumber) || blockNumber === -1) {\n            return provider;\n        }\n        return poll(() => {\n            return new Promise((resolve, reject) => {\n                setTimeout(function () {\n                    // We are synced\n                    if (provider.blockNumber >= blockNumber) {\n                        return resolve(provider);\n                    }\n                    // We're done; just quit\n                    if (config.cancelled) {\n                        return resolve(null);\n                    }\n                    // Try again, next block\n                    return resolve(undefined);\n                }, 0);\n            });\n        }, { oncePoll: provider });\n    });\n}\nfunction getRunner(config, currentBlockNumber, method, params) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let provider = config.provider;\n        switch (method) {\n            case \"getBlockNumber\":\n            case \"getGasPrice\":\n                return provider[method]();\n            case \"getEtherPrice\":\n                if (provider.getEtherPrice) {\n                    return provider.getEtherPrice();\n                }\n                break;\n            case \"getBalance\":\n            case \"getTransactionCount\":\n            case \"getCode\":\n                if (params.blockTag && isHexString(params.blockTag)) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider[method](params.address, params.blockTag || \"latest\");\n            case \"getStorageAt\":\n                if (params.blockTag && isHexString(params.blockTag)) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider.getStorageAt(params.address, params.position, params.blockTag || \"latest\");\n            case \"getBlock\":\n                if (params.blockTag && isHexString(params.blockTag)) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider[(params.includeTransactions ? \"getBlockWithTransactions\" : \"getBlock\")](params.blockTag || params.blockHash);\n            case \"call\":\n            case \"estimateGas\":\n                if (params.blockTag && isHexString(params.blockTag)) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider[method](params.transaction);\n            case \"getTransaction\":\n            case \"getTransactionReceipt\":\n                return provider[method](params.transactionHash);\n            case \"getLogs\": {\n                let filter = params.filter;\n                if ((filter.fromBlock && isHexString(filter.fromBlock)) || (filter.toBlock && isHexString(filter.toBlock))) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider.getLogs(filter);\n            }\n        }\n        return logger.throwError(\"unknown method error\", Logger.errors.UNKNOWN_ERROR, {\n            method: method,\n            params: params\n        });\n    });\n}\nexport class FallbackProvider extends BaseProvider {\n    constructor(providers, quorum) {\n        logger.checkNew(new.target, FallbackProvider);\n        if (providers.length === 0) {\n            logger.throwArgumentError(\"missing providers\", \"providers\", providers);\n        }\n        const providerConfigs = providers.map((configOrProvider, index) => {\n            if (Provider.isProvider(configOrProvider)) {\n                const stallTimeout = isCommunityResource(configOrProvider) ? 2000 : 750;\n                const priority = 1;\n                return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout, priority });\n            }\n            const config = shallowCopy(configOrProvider);\n            if (config.priority == null) {\n                config.priority = 1;\n            }\n            if (config.stallTimeout == null) {\n                config.stallTimeout = isCommunityResource(configOrProvider) ? 2000 : 750;\n            }\n            if (config.weight == null) {\n                config.weight = 1;\n            }\n            const weight = config.weight;\n            if (weight % 1 || weight > 512 || weight < 1) {\n                logger.throwArgumentError(\"invalid weight; must be integer in [1, 512]\", `providers[${index}].weight`, weight);\n            }\n            return Object.freeze(config);\n        });\n        const total = providerConfigs.reduce((accum, c) => (accum + c.weight), 0);\n        if (quorum == null) {\n            quorum = total / 2;\n        }\n        else if (quorum > total) {\n            logger.throwArgumentError(\"quorum will always fail; larger than total weight\", \"quorum\", quorum);\n        }\n        // Are all providers' networks are known\n        let networkOrReady = checkNetworks(providerConfigs.map((c) => (c.provider).network));\n        // Not all networks are known; we must stall\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    this.detectNetwork().then(resolve, reject);\n                }, 0);\n            });\n        }\n        super(networkOrReady);\n        // Preserve a copy, so we do not get mutated\n        defineReadOnly(this, \"providerConfigs\", Object.freeze(providerConfigs));\n        defineReadOnly(this, \"quorum\", quorum);\n        this._highestBlockNumber = -1;\n    }\n    detectNetwork() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const networks = yield Promise.all(this.providerConfigs.map((c) => c.provider.getNetwork()));\n            return checkNetworks(networks);\n        });\n    }\n    perform(method, params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Sending transactions is special; always broadcast it to all backends\n            if (method === \"sendTransaction\") {\n                const results = yield Promise.all(this.providerConfigs.map((c) => {\n                    return c.provider.sendTransaction(params.signedTransaction).then((result) => {\n                        return result.hash;\n                    }, (error) => {\n                        return error;\n                    });\n                }));\n                // Any success is good enough (other errors are likely \"already seen\" errors\n                for (let i = 0; i < results.length; i++) {\n                    const result = results[i];\n                    if (typeof (result) === \"string\") {\n                        return result;\n                    }\n                }\n                // They were all an error; pick the first error\n                throw results[0];\n            }\n            // We need to make sure we are in sync with our backends, so we need\n            // to know this before we can make a lot of calls\n            if (this._highestBlockNumber === -1 && method !== \"getBlockNumber\") {\n                yield this.getBlockNumber();\n            }\n            const processFunc = getProcessFunc(this, method, params);\n            // Shuffle the providers and then sort them by their priority; we\n            // shallowCopy them since we will store the result in them too\n            const configs = shuffled(this.providerConfigs.map(shallowCopy));\n            configs.sort((a, b) => (a.priority - b.priority));\n            const currentBlockNumber = this._highestBlockNumber;\n            let i = 0;\n            let first = true;\n            while (true) {\n                const t0 = now();\n                // Compute the inflight weight (exclude anything past)\n                let inflightWeight = configs.filter((c) => (c.runner && ((t0 - c.start) < c.stallTimeout)))\n                    .reduce((accum, c) => (accum + c.weight), 0);\n                // Start running enough to meet quorum\n                while (inflightWeight < this.quorum && i < configs.length) {\n                    const config = configs[i++];\n                    const rid = nextRid++;\n                    config.start = now();\n                    config.staller = stall(config.stallTimeout);\n                    config.staller.wait(() => { config.staller = null; });\n                    config.runner = getRunner(config, currentBlockNumber, method, params).then((result) => {\n                        config.done = true;\n                        config.result = result;\n                        if (this.listenerCount(\"debug\")) {\n                            this.emit(\"debug\", {\n                                action: \"request\",\n                                rid: rid,\n                                backend: exposeDebugConfig(config, now()),\n                                request: { method: method, params: deepCopy(params) },\n                                provider: this\n                            });\n                        }\n                    }, (error) => {\n                        config.done = true;\n                        config.error = error;\n                        if (this.listenerCount(\"debug\")) {\n                            this.emit(\"debug\", {\n                                action: \"request\",\n                                rid: rid,\n                                backend: exposeDebugConfig(config, now()),\n                                request: { method: method, params: deepCopy(params) },\n                                provider: this\n                            });\n                        }\n                    });\n                    if (this.listenerCount(\"debug\")) {\n                        this.emit(\"debug\", {\n                            action: \"request\",\n                            rid: rid,\n                            backend: exposeDebugConfig(config, null),\n                            request: { method: method, params: deepCopy(params) },\n                            provider: this\n                        });\n                    }\n                    inflightWeight += config.weight;\n                }\n                // Wait for anything meaningful to finish or stall out\n                const waiting = [];\n                configs.forEach((c) => {\n                    if (c.done || !c.runner) {\n                        return;\n                    }\n                    waiting.push(c.runner);\n                    if (c.staller) {\n                        waiting.push(c.staller.getPromise());\n                    }\n                });\n                if (waiting.length) {\n                    yield Promise.race(waiting);\n                }\n                // Check the quorum and process the results; the process function\n                // may additionally decide the quorum is not met\n                const results = configs.filter((c) => (c.done && c.error == null));\n                if (results.length >= this.quorum) {\n                    const result = processFunc(results);\n                    if (result !== undefined) {\n                        // Shut down any stallers\n                        configs.forEach(c => {\n                            if (c.staller) {\n                                c.staller.cancel();\n                            }\n                            c.cancelled = true;\n                        });\n                        return result;\n                    }\n                    if (!first) {\n                        yield stall(100).getPromise();\n                    }\n                    first = false;\n                }\n                // No result, check for errors that should be forwarded\n                const errors = configs.reduce((accum, c) => {\n                    if (!c.done || c.error == null) {\n                        return accum;\n                    }\n                    const code = (c.error).code;\n                    if (ForwardErrors.indexOf(code) >= 0) {\n                        if (!accum[code]) {\n                            accum[code] = { error: c.error, weight: 0 };\n                        }\n                        accum[code].weight += c.weight;\n                    }\n                    return accum;\n                }, ({}));\n                Object.keys(errors).forEach((errorCode) => {\n                    const tally = errors[errorCode];\n                    if (tally.weight < this.quorum) {\n                        return;\n                    }\n                    // Shut down any stallers\n                    configs.forEach(c => {\n                        if (c.staller) {\n                            c.staller.cancel();\n                        }\n                        c.cancelled = true;\n                    });\n                    const e = (tally.error);\n                    const props = {};\n                    ForwardProperties.forEach((name) => {\n                        if (e[name] == null) {\n                            return;\n                        }\n                        props[name] = e[name];\n                    });\n                    logger.throwError(e.reason || e.message, errorCode, props);\n                });\n                // All configs have run to completion; we will never get more data\n                if (configs.filter((c) => !c.done).length === 0) {\n                    break;\n                }\n            }\n            // Shut down any stallers; shouldn't be any\n            configs.forEach(c => {\n                if (c.staller) {\n                    c.staller.cancel();\n                }\n                c.cancelled = true;\n            });\n            return logger.throwError(\"failed to meet quorum\", Logger.errors.SERVER_ERROR, {\n                method: method,\n                params: params,\n                //results: configs.map((c) => c.result),\n                //errors: configs.map((c) => c.error),\n                results: configs.map((c) => exposeDebugConfig(c)),\n                provider: this\n            });\n        });\n    }\n}\n//# sourceMappingURL=fallback-provider.js.map","\"use strict\";\nconst IpcProvider = null;\nexport { IpcProvider };\n//# sourceMappingURL=ipc-provider.js.map","\"use strict\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { WebSocketProvider } from \"./websocket-provider\";\nimport { showThrottleMessage } from \"./formatter\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\nconst defaultProjectId = \"84842078b09946638c03157f83405213\";\nexport class InfuraWebSocketProvider extends WebSocketProvider {\n    constructor(network, apiKey) {\n        const provider = new InfuraProvider(network, apiKey);\n        const connection = provider.connection;\n        if (connection.password) {\n            logger.throwError(\"INFURA WebSocket project secrets unsupported\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"InfuraProvider.getWebSocketProvider()\"\n            });\n        }\n        const url = connection.url.replace(/^http/i, \"ws\").replace(\"/v3/\", \"/ws/v3/\");\n        super(url, network);\n        defineReadOnly(this, \"apiKey\", provider.projectId);\n        defineReadOnly(this, \"projectId\", provider.projectId);\n        defineReadOnly(this, \"projectSecret\", provider.projectSecret);\n    }\n    isCommunityResource() {\n        return (this.projectId === defaultProjectId);\n    }\n}\nexport class InfuraProvider extends UrlJsonRpcProvider {\n    static getWebSocketProvider(network, apiKey) {\n        return new InfuraWebSocketProvider(network, apiKey);\n    }\n    static getApiKey(apiKey) {\n        const apiKeyObj = {\n            apiKey: defaultProjectId,\n            projectId: defaultProjectId,\n            projectSecret: null\n        };\n        if (apiKey == null) {\n            return apiKeyObj;\n        }\n        if (typeof (apiKey) === \"string\") {\n            apiKeyObj.projectId = apiKey;\n        }\n        else if (apiKey.projectSecret != null) {\n            logger.assertArgument((typeof (apiKey.projectId) === \"string\"), \"projectSecret requires a projectId\", \"projectId\", apiKey.projectId);\n            logger.assertArgument((typeof (apiKey.projectSecret) === \"string\"), \"invalid projectSecret\", \"projectSecret\", \"[REDACTED]\");\n            apiKeyObj.projectId = apiKey.projectId;\n            apiKeyObj.projectSecret = apiKey.projectSecret;\n        }\n        else if (apiKey.projectId) {\n            apiKeyObj.projectId = apiKey.projectId;\n        }\n        apiKeyObj.apiKey = apiKeyObj.projectId;\n        return apiKeyObj;\n    }\n    static getUrl(network, apiKey) {\n        let host = null;\n        switch (network ? network.name : \"unknown\") {\n            case \"homestead\":\n                host = \"mainnet.infura.io\";\n                break;\n            case \"ropsten\":\n                host = \"ropsten.infura.io\";\n                break;\n            case \"rinkeby\":\n                host = \"rinkeby.infura.io\";\n                break;\n            case \"kovan\":\n                host = \"kovan.infura.io\";\n                break;\n            case \"goerli\":\n                host = \"goerli.infura.io\";\n                break;\n            case \"matic\":\n                host = \"polygon-mainnet.infura.io\";\n                break;\n            case \"maticmum\":\n                host = \"polygon-mumbai.infura.io\";\n                break;\n            default:\n                logger.throwError(\"unsupported network\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n        }\n        const connection = {\n            allowGzip: true,\n            url: (\"https:/\" + \"/\" + host + \"/v3/\" + apiKey.projectId),\n            throttleCallback: (attempt, url) => {\n                if (apiKey.projectId === defaultProjectId) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n        if (apiKey.projectSecret != null) {\n            connection.user = \"\";\n            connection.password = apiKey.projectSecret;\n        }\n        return connection;\n    }\n    isCommunityResource() {\n        return (this.projectId === defaultProjectId);\n    }\n}\n//# sourceMappingURL=infura-provider.js.map","import { deepCopy } from \"@ethersproject/properties\";\nimport { fetchJson } from \"@ethersproject/web\";\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\n// Experimental\nexport class JsonRpcBatchProvider extends JsonRpcProvider {\n    send(method, params) {\n        const request = {\n            method: method,\n            params: params,\n            id: (this._nextId++),\n            jsonrpc: \"2.0\"\n        };\n        if (this._pendingBatch == null) {\n            this._pendingBatch = [];\n        }\n        const inflightRequest = { request, resolve: null, reject: null };\n        const promise = new Promise((resolve, reject) => {\n            inflightRequest.resolve = resolve;\n            inflightRequest.reject = reject;\n        });\n        this._pendingBatch.push(inflightRequest);\n        if (!this._pendingBatchAggregator) {\n            // Schedule batch for next event loop + short duration\n            this._pendingBatchAggregator = setTimeout(() => {\n                // Get teh current batch and clear it, so new requests\n                // go into the next batch\n                const batch = this._pendingBatch;\n                this._pendingBatch = null;\n                this._pendingBatchAggregator = null;\n                // Get the request as an array of requests\n                const request = batch.map((inflight) => inflight.request);\n                this.emit(\"debug\", {\n                    action: \"requestBatch\",\n                    request: deepCopy(request),\n                    provider: this\n                });\n                return fetchJson(this.connection, JSON.stringify(request)).then((result) => {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        request: request,\n                        response: result,\n                        provider: this\n                    });\n                    // For each result, feed it to the correct Promise, depending\n                    // on whether it was a success or error\n                    batch.forEach((inflightRequest, index) => {\n                        const payload = result[index];\n                        if (payload.error) {\n                            const error = new Error(payload.error.message);\n                            error.code = payload.error.code;\n                            error.data = payload.error.data;\n                            inflightRequest.reject(error);\n                        }\n                        else {\n                            inflightRequest.resolve(payload.result);\n                        }\n                    });\n                }, (error) => {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: request,\n                        provider: this\n                    });\n                    batch.forEach((inflightRequest) => {\n                        inflightRequest.reject(error);\n                    });\n                });\n            }, 10);\n        }\n        return promise;\n    }\n}\n//# sourceMappingURL=json-rpc-batch-provider.js.map","/* istanbul ignore file */\n\"use strict\";\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n// Special API key provided by Nodesmith for ethers.js\nconst defaultApiKey = \"ETHERS_JS_SHARED\";\nexport class NodesmithProvider extends UrlJsonRpcProvider {\n    static getApiKey(apiKey) {\n        if (apiKey && typeof (apiKey) !== \"string\") {\n            logger.throwArgumentError(\"invalid apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKey || defaultApiKey;\n    }\n    static getUrl(network, apiKey) {\n        logger.warn(\"NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.\");\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc\";\n                break;\n            case \"ropsten\":\n                host = \"https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc\";\n                break;\n            case \"rinkeby\":\n                host = \"https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc\";\n                break;\n            case \"goerli\":\n                host = \"https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc\";\n                break;\n            case \"kovan\":\n                host = \"https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc\";\n                break;\n            default:\n                logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n        return (host + \"?apiKey=\" + apiKey);\n    }\n}\n//# sourceMappingURL=nodesmith-provider.js.map","\"use strict\";\nimport { getStatic } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n// These are load-balancer-based applicatoin IDs\nconst defaultApplicationIds = {\n    homestead: \"6004bcd10040261633ade990\",\n    ropsten: \"6004bd4d0040261633ade991\",\n    rinkeby: \"6004bda20040261633ade994\",\n    goerli: \"6004bd860040261633ade992\",\n};\nexport class PocketProvider extends UrlJsonRpcProvider {\n    constructor(network, apiKey) {\n        // We need a bit of creativity in the constructor because\n        // Pocket uses different default API keys based on the network\n        if (apiKey == null) {\n            const n = getStatic((new.target), \"getNetwork\")(network);\n            if (n) {\n                const applicationId = defaultApplicationIds[n.name];\n                if (applicationId) {\n                    apiKey = {\n                        applicationId: applicationId,\n                        loadBalancer: true\n                    };\n                }\n            }\n            // If there was any issue above, we don't know this network\n            if (apiKey == null) {\n                logger.throwError(\"unsupported network\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n            }\n        }\n        super(network, apiKey);\n    }\n    static getApiKey(apiKey) {\n        // Most API Providers allow null to get the default configuration, but\n        // Pocket requires the network to decide the default provider, so we\n        // rely on hijacking the constructor to add a sensible default for us\n        if (apiKey == null) {\n            logger.throwArgumentError(\"PocketProvider.getApiKey does not support null apiKey\", \"apiKey\", apiKey);\n        }\n        const apiKeyObj = {\n            applicationId: null,\n            loadBalancer: false,\n            applicationSecretKey: null\n        };\n        // Parse applicationId and applicationSecretKey\n        if (typeof (apiKey) === \"string\") {\n            apiKeyObj.applicationId = apiKey;\n        }\n        else if (apiKey.applicationSecretKey != null) {\n            logger.assertArgument((typeof (apiKey.applicationId) === \"string\"), \"applicationSecretKey requires an applicationId\", \"applicationId\", apiKey.applicationId);\n            logger.assertArgument((typeof (apiKey.applicationSecretKey) === \"string\"), \"invalid applicationSecretKey\", \"applicationSecretKey\", \"[REDACTED]\");\n            apiKeyObj.applicationId = apiKey.applicationId;\n            apiKeyObj.applicationSecretKey = apiKey.applicationSecretKey;\n            apiKeyObj.loadBalancer = !!apiKey.loadBalancer;\n        }\n        else if (apiKey.applicationId) {\n            logger.assertArgument((typeof (apiKey.applicationId) === \"string\"), \"apiKey.applicationId must be a string\", \"apiKey.applicationId\", apiKey.applicationId);\n            apiKeyObj.applicationId = apiKey.applicationId;\n            apiKeyObj.loadBalancer = !!apiKey.loadBalancer;\n        }\n        else {\n            logger.throwArgumentError(\"unsupported PocketProvider apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKeyObj;\n    }\n    static getUrl(network, apiKey) {\n        let host = null;\n        switch (network ? network.name : \"unknown\") {\n            case \"homestead\":\n                host = \"eth-mainnet.gateway.pokt.network\";\n                break;\n            case \"ropsten\":\n                host = \"eth-ropsten.gateway.pokt.network\";\n                break;\n            case \"rinkeby\":\n                host = \"eth-rinkeby.gateway.pokt.network\";\n                break;\n            case \"goerli\":\n                host = \"eth-goerli.gateway.pokt.network\";\n                break;\n            default:\n                logger.throwError(\"unsupported network\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n        }\n        let url = null;\n        if (apiKey.loadBalancer) {\n            url = `https:/\\/${host}/v1/lb/${apiKey.applicationId}`;\n        }\n        else {\n            url = `https:/\\/${host}/v1/${apiKey.applicationId}`;\n        }\n        const connection = { url };\n        // Initialize empty headers\n        connection.headers = {};\n        // Apply application secret key\n        if (apiKey.applicationSecretKey != null) {\n            connection.user = \"\";\n            connection.password = apiKey.applicationSecretKey;\n        }\n        return connection;\n    }\n    isCommunityResource() {\n        return (this.applicationId === defaultApplicationIds[this.network.name]);\n    }\n}\n//# sourceMappingURL=pocket-provider.js.map","\"use strict\";\nimport { deepCopy, defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\nlet _nextId = 1;\nfunction buildWeb3LegacyFetcher(provider, sendFunc) {\n    const fetcher = \"Web3LegacyFetcher\";\n    return function (method, params) {\n        // Metamask complains about eth_sign (and on some versions hangs)\n        if (method == \"eth_sign\" && (provider.isMetaMask || provider.isStatus)) {\n            // https://github.com/ethereum/go-ethereum/wiki/Management-APIs#personal_sign\n            method = \"personal_sign\";\n            params = [params[1], params[0]];\n        }\n        const request = {\n            method: method,\n            params: params,\n            id: (_nextId++),\n            jsonrpc: \"2.0\"\n        };\n        return new Promise((resolve, reject) => {\n            this.emit(\"debug\", {\n                action: \"request\",\n                fetcher,\n                request: deepCopy(request),\n                provider: this\n            });\n            sendFunc(request, (error, response) => {\n                if (error) {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        fetcher,\n                        error,\n                        request,\n                        provider: this\n                    });\n                    return reject(error);\n                }\n                this.emit(\"debug\", {\n                    action: \"response\",\n                    fetcher,\n                    request,\n                    response,\n                    provider: this\n                });\n                if (response.error) {\n                    const error = new Error(response.error.message);\n                    error.code = response.error.code;\n                    error.data = response.error.data;\n                    return reject(error);\n                }\n                resolve(response.result);\n            });\n        });\n    };\n}\nfunction buildEip1193Fetcher(provider) {\n    return function (method, params) {\n        if (params == null) {\n            params = [];\n        }\n        // Metamask complains about eth_sign (and on some versions hangs)\n        if (method == \"eth_sign\" && (provider.isMetaMask || provider.isStatus)) {\n            // https://github.com/ethereum/go-ethereum/wiki/Management-APIs#personal_sign\n            method = \"personal_sign\";\n            params = [params[1], params[0]];\n        }\n        const request = { method, params };\n        this.emit(\"debug\", {\n            action: \"request\",\n            fetcher: \"Eip1193Fetcher\",\n            request: deepCopy(request),\n            provider: this\n        });\n        return provider.request(request).then((response) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                fetcher: \"Eip1193Fetcher\",\n                request,\n                response,\n                provider: this\n            });\n            return response;\n        }, (error) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                fetcher: \"Eip1193Fetcher\",\n                request,\n                error,\n                provider: this\n            });\n            throw error;\n        });\n    };\n}\nexport class Web3Provider extends JsonRpcProvider {\n    constructor(provider, network) {\n        logger.checkNew(new.target, Web3Provider);\n        if (provider == null) {\n            logger.throwArgumentError(\"missing provider\", \"provider\", provider);\n        }\n        let path = null;\n        let jsonRpcFetchFunc = null;\n        let subprovider = null;\n        if (typeof (provider) === \"function\") {\n            path = \"unknown:\";\n            jsonRpcFetchFunc = provider;\n        }\n        else {\n            path = provider.host || provider.path || \"\";\n            if (!path && provider.isMetaMask) {\n                path = \"metamask\";\n            }\n            subprovider = provider;\n            if (provider.request) {\n                if (path === \"\") {\n                    path = \"eip-1193:\";\n                }\n                jsonRpcFetchFunc = buildEip1193Fetcher(provider);\n            }\n            else if (provider.sendAsync) {\n                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));\n            }\n            else if (provider.send) {\n                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));\n            }\n            else {\n                logger.throwArgumentError(\"unsupported provider\", \"provider\", provider);\n            }\n            if (!path) {\n                path = \"unknown:\";\n            }\n        }\n        super(path, network);\n        defineReadOnly(this, \"jsonRpcFetchFunc\", jsonRpcFetchFunc);\n        defineReadOnly(this, \"provider\", subprovider);\n    }\n    send(method, params) {\n        return this.jsonRpcFetchFunc(method, params);\n    }\n}\n//# sourceMappingURL=web3-provider.js.map","\"use strict\";\nimport { BaseContract, Contract, ContractFactory } from \"@ethersproject/contracts\";\nimport { BigNumber, FixedNumber } from \"@ethersproject/bignumber\";\nimport { Signer, VoidSigner } from \"@ethersproject/abstract-signer\";\nimport { Wallet } from \"@ethersproject/wallet\";\nimport * as constants from \"@ethersproject/constants\";\nimport * as providers from \"@ethersproject/providers\";\nimport { getDefaultProvider } from \"@ethersproject/providers\";\nimport { Wordlist, wordlists } from \"@ethersproject/wordlists\";\nimport * as utils from \"./utils\";\nimport { ErrorCode as errors, Logger } from \"@ethersproject/logger\";\n////////////////////////\n// Compile-Time Constants\n// This is generated by \"npm run dist\"\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n////////////////////////\n// Exports\nexport { Signer, Wallet, VoidSigner, getDefaultProvider, providers, BaseContract, Contract, ContractFactory, BigNumber, FixedNumber, constants, errors, logger, utils, wordlists, \n////////////////////////\n// Compile-Time Constants\nversion, Wordlist };\n//# sourceMappingURL=ethers.js.map","// NFKC (composed)             // (decomposed)\nexport const EtherSymbol = \"\\u039e\"; // \"\\uD835\\uDF63\";\n//# sourceMappingURL=strings.js.map"],"sourceRoot":""}